import { motion, AnimatePresence } from "framer-motion";

import { BrokerData } from "@/components/broker-data";

import React, {
  useState,
  useEffect,
  useMemo,
  useCallback,
  useRef,
} from "react";
import { useLocation } from "wouter";

import { useToast } from "@/hooks/use-toast";

import { AuthButtonAngelOne, AngelOneStatus, AngelOneApiStatistics, AngelOneSystemStatus, AngelOneLiveMarketPrices } from "@/components/auth-button-angelone";

import { AuthButtonUpstox } from "@/components/auth-button-upstox";

import { TradingJournalModal } from "@/components/trading-journal-modal";

// REMOVED: All Fyers-related imports
// import { AuthButton } from "@/components/auth-button";

// import { ConnectionStatus } from "@/components/connection-status";

// import { MonthlyProgressTracker } from "@/components/monthly-progress-tracker";

// import { ApiStatistics } from "@/components/api-statistics";

// import { ErrorPanel } from "@/components/error-panel";

import { SigninDataWindow } from "@/components/signin-data-window";

import { TradingViewWidget } from "@/components/tradingview-widget";

import { AdvancedCandlestickChart } from "@/components/advanced-candlestick-chart";

import { EnhancedTradingViewWidget } from "@/components/enhanced-tradingview-widget";

import { TradingViewStyleChart } from "@/components/tradingview-style-chart";

import { MinimalChart } from "@/components/minimal-chart";

import {

  MultipleImageUpload,
  MultipleImageUploadRef,
} from "@/components/multiple-image-upload";
import { IndicatorCrossingsDisplay } from "@/components/indicator-crossings-display";

// import { BattuScanSimulation } from "@/components/battu-scan-simulation";

// import { FourCandleRuleScanner } from "@/components/four-candle-rule-scanner";

import NeoFeedSocialFeed from "@/components/neofeed-social-feed";
import SimpleCompleteScanner from "@/components/simple-complete-scanner";
// import { BattuDocumentationDisplay } from "@/components/battu-documentation-display";

import { StrategyBuilder } from "@/components/strategy-builder";

import { TradingMaster } from "@/components/trading-master";

import { WorldMap } from "@/components/world-map";

import { DemoHeatmap } from "@/components/DemoHeatmap";

import { PersonalHeatmap } from "@/components/PersonalHeatmap";

import { useTheme } from "@/components/theme-provider";

import { useCurrentUser } from "@/hooks/useCurrentUser";

import { useAngelOneAutoconnect } from "@/hooks/useAngelOneAutoconnect";

import { cognitoSignOut, getCognitoToken, sendEmailVerificationCode, confirmEmailVerification, checkEmailVerified } from "@/cognito";

import { createChart, ColorType, IChartApi, ISeriesApi, CandlestickSeries, LineSeries, HistogramSeries, IPriceLine, createSeriesMarkers } from 'lightweight-charts';

import { ArrowLeft, Banknote, Clock, ExternalLink, Info, Loader2, LogOut, Newspaper, RefreshCw, Save, TrendingUp, Award, Headset, X, Play, Music2, Pencil, CheckCircle } from "lucide-react";

import { parseBrokerTrades, ParseError } from "@/utils/trade-parser";


// Global window type declaration for audio control
declare global {
  interface Window {
    stopNewsAudio?: () => void;
  }
}

// import ThreeCycleScanner from "@/components/three-cycle-scanner";
import HistoricalTradeSimulator from "@/components/historical-trade-simulator";
import {

  PriceChangeAnimation,
  TradeExecutionAnimation,
  VolumeSpikeAnimation,
  MarketStatusPulse,
  ProfitLossAnimation,
  CandlestickAnimation,
  MarketDataSkeleton,
} from "@/components/micro-animations";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";

import {

  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";

import { Input } from "@/components/ui/input";

import { Label } from "@/components/ui/label";

import { Switch } from "@/components/ui/switch";

import {

  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Textarea } from "@/components/ui/textarea";

import {

  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {

  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {

  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

import {

  TrendingDown,
  Activity,
  Calendar,
  BarChart3,
  
  Pause,
  RotateCcw,
  RotateCw,
  DollarSign,
  Zap,
  Sun,
  Moon,
  GraduationCap,
  Download,
  Mic,
  MessageCircle,
  BookOpen,
  Home as HomeIcon,
  Search,
  Code,
  PenTool,
  Target,
  Grid3X3,
  Send,
  Sparkles,
  Users,
  Upload,
  Timer,
  Edit,
  Check,
  Mail,
  
  ChevronLeft,
  ChevronRight,
  ChevronDown,
  ChevronUp,
  Tag,
  Trash2,
  AlertTriangle,
  AlertCircle,
  Shield,
  Bot,
  User,
  SkipBack,
  SkipForward,
  Heart,
  Lightbulb,
  Star,
  FileText,
  Bell,
  Briefcase,
  PieChart,
  Lock,
  Trophy,
  Radio,
  Eye,
  EyeOff,
  Blocks,
  Hammer,
  Plus,
  Share2,
  Copy,
  Link2,
  Facebook,
  Linkedin,
  Twitter,
  Settings,
  Filter,
  Radar,
  RefreshCcw,
  MoreVertical,
  ChevronsUpDown,
  CalendarDays,
  Brain,
  ShieldCheck,
} from "lucide-react";
import { AIChatWindow } from "@/components/ai-chat-window";

import { BrokerImportDialog } from "@/components/broker-import-dialog";

import { TradeBlockEditor } from "@/components/TradeBlockEditor";

import type { BrokerTrade } from "@shared/schema";

// Type definitions for stock data and trading
interface StockData {
  symbol: string;
  price: number;
  change: number;
  changePercent: number;
  volume: string | number;
  marketCap: string;
  pe: number;
  high: number;
  low: number;
  open: number;
  sentiment: {
    trend?: string;
    confidence?: string;
    score?: number;
  } | null;
  indicators: {
    rsi?: string;
    ema50?: string;
    macd?: string;
  } | null;
}

interface TradeMarker {
  candleIndex: number;
  price: number;
  type: "buy" | "sell";
  symbol: string;
  quantity: number;
  time: string;
  pnl: string;
}

// SwipeableCardStack Component
interface SwipeableCardStackProps {
  onSectorChange: (sector: string) => void;
  selectedSector: string;
  onCardIndexChange?: (index: number) => void;
  currentCardIndex?: number;
}

function SwipeableCardStack({
  onSectorChange,
  selectedSector,
  onCardIndexChange,
  currentCardIndex = 0,
}: SwipeableCardStackProps) {
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentContent, setCurrentContent] = useState<string>("");
  const [isLoading, setIsLoading] = useState(false);
  const [currentAudio, setCurrentAudio] =
    useState<SpeechSynthesisUtterance | null>(null);

  const [cards, setCards] = useState([
    {
      id: 1,
      title: "TECH NEWS",
      subtitle: "Latest in\ntechnology",
      buttonText: "Read Now",
      gradient: "from-blue-500 to-blue-600",
      buttonColor: "text-blue-600",
      icon: "💻",
      sector: "IT",
    },
    {
      id: 2,
      title: "FINANCE NEWS",
      subtitle: "Market updates\n& trends",
      buttonText: "Listen",
      gradient: "from-green-500 to-green-600",
      buttonColor: "text-green-600",
      icon: "📈",
      sector: "FINANCE",
    },
    {
      id: 3,
      title: "COMMODITY NEWS",
      subtitle: "Commodity\nmarket trends",
      buttonText: "Listen",
      gradient: "from-orange-500 to-orange-600",
      buttonColor: "text-orange-600",
      icon: "🏗️",
      sector: "COMMODITY",
    },
    {
      id: 4,
      title: "GLOBAL NEWS",
      subtitle: "World events\n& updates",
      buttonText: "Listen",
      gradient: "from-purple-500 to-purple-600",
      buttonColor: "text-purple-600",
      icon: "🌍",
      sector: "GLOBAL",
    },
    {
      id: 5,
      title: "BANKING NEWS",
      subtitle: "Banking sector\nupdates",
      buttonText: "Listen",
      gradient: "from-indigo-500 to-indigo-600",
      buttonColor: "text-indigo-600",
      icon: "🏦",
      sector: "BANKS",
    },
    {
      id: 6,
      title: "AUTO NEWS",
      subtitle: "Automotive\nindustry news",
      buttonText: "Listen",
      gradient: "from-red-500 to-red-600",
      buttonColor: "text-red-600",
      icon: "🚗",
      sector: "AUTOMOBILE",
    },
  ]);

  // News cache for faster loading - ultra-short cache for speed
  const newsCache = React.useRef<
    Record<string, { content: string; timestamp: number }>
  >({});
  const CACHE_DURATION = 10 * 1000; // 10 seconds - ultra-short for instant refresh

  // Global cleanup function to stop all audio
  const globalStopAudio = React.useCallback(() => {
    if (currentAudio) {
      speechSynthesis.cancel();
      setCurrentAudio(null);
      setIsPlaying(false);
    }
  }, [currentAudio]);

  // Fetch AI-generated news content for current card with caching
  const fetchAndPlayContent = async (cardTitle: string, sector: string) => {
    // Stop any currently playing audio immediately
    globalStopAudio();

    try {
      setIsLoading(true);

      // Check cache first
      const cacheKey = sector;
      const cachedData = newsCache.current[cacheKey];
      const now = Date.now();

      if (cachedData && now - cachedData.timestamp < CACHE_DURATION) {
        // Use cached content
        setCurrentContent(cachedData.content);
        playAudio(cachedData.content);
        setIsLoading(false);
        return;
      }

      const response = await fetch(getFullApiUrl("/api/daily-news"), {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ sector: sector }),
      });

      if (!response.ok) {
        throw new Error("Failed to generate news content");
      }

      const data = await response.json();
      const content = data.summary;

      // Cache the content
      newsCache.current[cacheKey] = {
        content,
        timestamp: now,
      };

      setCurrentContent(content);
      playAudio(content);
    } catch (error) {
      console.error("Error fetching news:", error);
      const fallbackContent = `${sector.toLowerCase()} market update. Current developments in progress. Trading activity continues.`;
      setCurrentContent(fallbackContent);
      playAudio(fallbackContent);
    } finally {
      setIsLoading(false);
    }
  };

  // Play audio using Speech Synthesis with optimized settings
  const playAudio = (text: string) => {
    // Stop current audio if playing
    if (currentAudio) {
      speechSynthesis.cancel();
    }

    // Clean the text to remove any potential greetings
    const cleanText = text
      .replace(
        /^(good morning|good afternoon|good evening|hello|hi|welcome)/gi,
        "",
      )
      .replace(/^(ladies and gentlemen|dear listeners|in today's news)/gi, "")
      .replace(/^[.,\s]+/, "") // Remove leading punctuation and spaces
      .trim();

    const utterance = new SpeechSynthesisUtterance(cleanText);

    // Get available voices and select neutral/direct voices
    const voices = speechSynthesis.getVoices();

    // Prioritize Moira voice specifically, then other natural voices
    const moiraVoice = voices.find(
      (voice) =>
        voice.lang.startsWith("en") &&
        voice.name.toLowerCase().includes("moira"),
    );

    const otherNaturalVoices = voices.filter(
      (voice) =>
        voice.lang.startsWith("en") &&
        !voice.name.toLowerCase().includes("moira") &&
        // Other premium female voices that sound very natural
        (voice.name.toLowerCase().includes("samantha") ||
          voice.name.toLowerCase().includes("karen") ||
          voice.name.toLowerCase().includes("susan") ||
          voice.name.toLowerCase().includes("fiona") ||
          voice.name.toLowerCase().includes("serena") ||
          voice.name.toLowerCase().includes("allison") ||
          voice.name.toLowerCase().includes("ava") ||
          voice.name.toLowerCase().includes("claire") ||
          voice.name.toLowerCase().includes("aria") ||
          voice.name.toLowerCase().includes("zira") ||
          voice.name.toLowerCase().includes("hazel") ||
          // Neural/premium indicators
          voice.name.toLowerCase().includes("neural") ||
          voice.name.toLowerCase().includes("premium") ||
          voice.name.toLowerCase().includes("enhanced")),
    );

    // Use Moira first, then other natural voices, then any English voice
    if (moiraVoice) {
      utterance.voice = moiraVoice;
    } else if (otherNaturalVoices.length > 0) {
      utterance.voice = otherNaturalVoices[0];
    } else {
      const englishVoices = voices.filter(
        (voice) =>
          voice.lang.startsWith("en") &&
          !voice.name.toLowerCase().includes("novelty"),
      );
      if (englishVoices.length > 0) {
        utterance.voice = englishVoices[0];
      }
    }

    // Settings for natural, human-like delivery
    utterance.rate = 0.9; // Slightly slower for more natural pacing
    utterance.pitch = 1.05; // Slight variation for more natural sound
    utterance.volume = 0.85; // Comfortable listening volume

    // Set language for neutral pronunciation
    utterance.lang = "en-US";

    utterance.onstart = () => setIsPlaying(true);
    utterance.onend = () => {
      setIsPlaying(false);
      setCurrentAudio(null);
    };
    utterance.onerror = () => {
      setIsPlaying(false);
      setCurrentAudio(null);
    };

    setCurrentAudio(utterance);
    speechSynthesis.speak(utterance);
  };

  // Stop audio playback
  const stopAudio = () => {
    if (currentAudio) {
      speechSynthesis.cancel();
      setIsPlaying(false);
      setCurrentAudio(null);
    }
  };

  const swipeCard = (direction: "left" | "right") => {
    // Immediately stop current audio
    globalStopAudio();

    setCards((prev) => {
      const newCards = [...prev];
      let newIndex = currentCardIndex;

      if (direction === "right") {
        // Right swipe: Move to next card (current card goes to back)
        const topCard = newCards.shift();
        if (topCard) {
          newCards.push(topCard);
        }
        newIndex = (currentCardIndex + 1) % 7;
      } else {
        // Left swipe: Move to previous card (bottom card comes to front)
        const bottomCard = newCards.pop();
        if (bottomCard) {
          newCards.unshift(bottomCard);
        }
        newIndex = (currentCardIndex - 1 + 7) % 7;
      }

      // Notify parent of index change
      if (onCardIndexChange) {
        onCardIndexChange(newIndex);
      }

      // Auto-play content for the new front card (faster response)
      if (newCards.length > 0) {
        const frontCard = newCards[0];
        setTimeout(() => {
          fetchAndPlayContent(frontCard.title, frontCard.sector);
        }, 100); // Reduced delay for faster response
      }

      return newCards;
    });
  };

  // Expose global stop function to window for tab switching
  React.useEffect(() => {
    window.stopNewsAudio = globalStopAudio;

    return () => {
      delete window.stopNewsAudio;
    };
  }, [globalStopAudio]);

  // Add window focus/blur detection to stop voice when clicking away
  React.useEffect(() => {
    const handleWindowBlur = () => {
      // Stop audio when user clicks away from the window
      globalStopAudio();
    };

    const handleVisibilityChange = () => {
      // Stop audio when tab becomes hidden
      if (document.hidden) {
        globalStopAudio();
      }
    };

    // Listen for window losing focus
    window.addEventListener("blur", handleWindowBlur);
    // Listen for tab visibility changes
    document.addEventListener("visibilitychange", handleVisibilityChange);

    return () => {
      window.removeEventListener("blur", handleWindowBlur);
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, [globalStopAudio]);

  // Load voices on component mount
  React.useEffect(() => {
    // Ensure voices are loaded
    const loadVoices = () => {
      speechSynthesis.getVoices();
    };

    // Load voices immediately and on voiceschanged event
    loadVoices();
    speechSynthesis.addEventListener("voiceschanged", loadVoices);

    // Cleanup on unmount
    return () => {
      speechSynthesis.removeEventListener("voiceschanged", loadVoices);
      globalStopAudio(); // Stop any playing audio when component unmounts
    };
  }, [globalStopAudio]);

  // Voice functionality is now only triggered by manual clicks

  return (
    <div className="relative w-56 h-48 md:w-44 md:h-52">
      {cards.map((card, index) => {
        const isTop = index === 0;
        const isSecond = index === 1;
        const isThird = index === 2;

        return (
          <div
            key={card.id}
            data-card-index={index}
            className={`absolute inset-0 transition-all duration-300 ease-out cursor-grab active:cursor-grabbing ${
              isTop
                ? "z-40 scale-100 rotate-0"
                : isSecond
                  ? "z-30 scale-95 rotate-1 translate-y-2"
                  : isThird
                    ? "z-20 scale-90 rotate-2 translate-y-4"
                    : "z-10 scale-85 rotate-3 translate-y-6 opacity-50"
            }`}
            onMouseDown={(e: React.MouseEvent<HTMLDivElement>) => {
              if (!isTop) return;

              const startX = e.clientX;
              const startY = e.clientY;
              const cardElement = e.currentTarget as HTMLElement;
              let isDragging = false;

              const handleMouseMove = (e: MouseEvent) => {
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;

                if (
                  !isDragging &&
                  (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5)
                ) {
                  isDragging = true;
                }

                if (isDragging) {
                  const rotation = deltaX * 0.1;
                  cardElement.style.transform = `translate(${deltaX}px, ${deltaY}px) rotate(${rotation}deg)`;
                  cardElement.style.opacity = String(
                    Math.max(0.3, 1 - Math.abs(deltaX) / 300),
                  );
                }
              };

              const handleMouseUp = (e: MouseEvent) => {
                if (isDragging) {
                  const deltaX = e.clientX - startX;
                  if (Math.abs(deltaX) > 100) {
                    // Determine swipe direction
                    const swipeDirection = deltaX > 0 ? "right" : "left";

                    if (swipeDirection === "right") {
                      // Right swipe: Card moves away animation
                      const direction = "150%";
                      const rotation = "30deg";
                      cardElement.style.transform = `translate(${direction}, ${
                        deltaX * 0.5
                      }px) rotate(${rotation})`;
                      cardElement.style.opacity = "0";

                      setTimeout(() => {
                        cardElement.style.transform = "";
                        cardElement.style.opacity = "";
                        swipeCard(swipeDirection);
                      }, 300);
                    } else {
                      // Left swipe: Previous card slides in from left (reverse animation)
                      cardElement.style.transform = "";
                      cardElement.style.opacity = "";

                      // Change the card order first
                      swipeCard(swipeDirection);

                      // Then animate the new top card sliding in from the right (coming back)
                      setTimeout(() => {
                        const newTopCard =
                          cardElement.parentElement?.querySelector(
                            '[data-card-index="0"]',
                          ) as HTMLElement;
                        if (newTopCard) {
                          // Start from right side with rotation (like it's coming back)
                          newTopCard.style.transform =
                            "translate(150%, 0) rotate(30deg)";
                          newTopCard.style.opacity = "0";

                          // Animate to center
                          setTimeout(() => {
                            newTopCard.style.transform = "";
                            newTopCard.style.opacity = "";
                            newTopCard.style.transition =
                              "transform 300ms ease-out, opacity 300ms ease-out";

                            // Clear transition after animation
                            setTimeout(() => {
                              newTopCard.style.transition = "";
                            }, 300);
                          }, 10);
                        }
                      }, 10);
                    }
                  } else {
                    // Snap back to center
                    cardElement.style.transform = "";
                    cardElement.style.opacity = "";
                  }
                }

                document.removeEventListener("mousemove", handleMouseMove);
                document.removeEventListener("mouseup", handleMouseUp);
              };

              document.addEventListener("mousemove", handleMouseMove);
              document.addEventListener("mouseup", handleMouseUp);
            }}
            onTouchStart={(e: React.TouchEvent<HTMLDivElement>) => {
              if (!isTop) return;

              const startX = e.touches[0].clientX;
              const startY = e.touches[0].clientY;
              const cardElement = e.currentTarget as HTMLElement;
              let isDragging = false;

              const handleTouchMove = (e: TouchEvent) => {
                const deltaX = e.touches[0].clientX - startX;
                const deltaY = e.touches[0].clientY - startY;

                if (
                  !isDragging &&
                  (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5)
                ) {
                  isDragging = true;
                }

                if (isDragging) {
                  e.preventDefault();
                  const rotation = deltaX * 0.1;
                  cardElement.style.transform = `translate(${deltaX}px, ${deltaY}px) rotate(${rotation}deg)`;
                  cardElement.style.opacity = String(
                    Math.max(0.3, 1 - Math.abs(deltaX) / 300),
                  );
                }
              };

              const handleTouchEnd = (e: TouchEvent) => {
                if (isDragging) {
                  const deltaX = e.changedTouches[0].clientX - startX;
                  if (Math.abs(deltaX) > 100) {
                    // Determine swipe direction
                    const swipeDirection = deltaX > 0 ? "right" : "left";

                    if (swipeDirection === "right") {
                      // Right swipe: Card moves away animation
                      const direction = "150%";
                      const rotation = "30deg";
                      cardElement.style.transform = `translate(${direction}, ${
                        deltaX * 0.5
                      }px) rotate(${rotation})`;
                      cardElement.style.opacity = "0";

                      setTimeout(() => {
                        cardElement.style.transform = "";
                        cardElement.style.opacity = "";
                        swipeCard(swipeDirection);
                      }, 300);
                    } else {
                      // Left swipe: Previous card slides in from left (reverse animation)
                      cardElement.style.transform = "";
                      cardElement.style.opacity = "";

                      // Change the card order first
                      swipeCard(swipeDirection);

                      // Then animate the new top card sliding in from the right (coming back)
                      setTimeout(() => {
                        const newTopCard =
                          cardElement.parentElement?.querySelector(
                            '[data-card-index="0"]',
                          ) as HTMLElement;
                        if (newTopCard) {
                          // Start from right side with rotation (like it's coming back)
                          newTopCard.style.transform =
                            "translate(150%, 0) rotate(30deg)";
                          newTopCard.style.opacity = "0";

                          // Animate to center
                          setTimeout(() => {
                            newTopCard.style.transform = "";
                            newTopCard.style.opacity = "";
                            newTopCard.style.transition =
                              "transform 300ms ease-out, opacity 300ms ease-out";

                            // Clear transition after animation
                            setTimeout(() => {
                              newTopCard.style.transition = "";
                            }, 300);
                          }, 10);
                        }
                      }, 10);
                    }
                  } else {
                    // Snap back to center
                    cardElement.style.transform = "";
                    cardElement.style.opacity = "";
                  }
                }

                document.removeEventListener("touchmove", handleTouchMove);
                document.removeEventListener("touchend", handleTouchEnd);
              };

              document.addEventListener("touchmove", handleTouchMove, {
                passive: false,
              });
              document.addEventListener("touchend", handleTouchEnd);
            }}
            onClick={() => {
              if (isTop) {
                console.log(`Clicked on ${card.title}`);
                onSectorChange(card.sector);
              }
            }}
          >
            <div
              className={`bg-gradient-to-br ${card.gradient} rounded-2xl p-5 md:p-6 h-full relative overflow-hidden shadow-xl border-2 border-white/10 flex flex-col`}
            >
              {/* Character illustration area */}
              <div className="absolute bottom-0 right-0 w-20 h-20 md:w-24 md:h-24 opacity-20">
                <div className="w-full h-full bg-gradient-to-br from-white/20 to-white/10 rounded-full"></div>
              </div>

              {/* Card content */}
              <div className="relative z-10 flex flex-col h-full">
                <div className="text-[10px] md:text-[9px] text-white/90 mb-1 md:mb-1.5 uppercase tracking-wider font-semibold">
                  {card.title}
                </div>
                <h3 className="text-lg md:text-base font-bold text-white mb-3 md:mb-3 leading-snug flex-grow">
                  {card.subtitle.split("\n").map((line, i) => (
                    <div key={i} className="block">{line}</div>
                  ))}
                </h3>
                <Button
                  className={`bg-white ${card.buttonColor} hover:bg-gray-100 px-3 py-1.5 md:px-3 md:py-1 rounded-full text-xs md:text-[11px] font-semibold shadow-lg w-fit`}
                  onClick={() => {
                    if (isTop) {
                      const userId = localStorage.getItem('currentUserId');
                      const userEmail = localStorage.getItem('currentUserEmail');

                      if (!userId || !userEmail) {
                        console.log('🔒 User not authenticated, redirecting to login');
                        window.location.href = '/login';
                        return;
                      }

                      if (isPlaying) {
                        stopAudio();
                      } else {
                        fetchAndPlayContent(card.title, card.sector);
                      }
                    }
                  }}
                  disabled={isLoading && isTop}
                >
                  <div className="flex items-center gap-2">
                    {isTop && isLoading ? (
                      <RotateCcw className="w-4 h-4 animate-spin" />
                    ) : isTop && isPlaying ? (
                      <Pause className="w-4 h-4" />
                    ) : (
                      <Play className="w-4 h-4" />
                    )}
                    <span>
                      {isTop && isLoading
                        ? "Generating..."
                        : isTop && isPlaying
                          ? "Pause"
                          : card.buttonText}
                    </span>
                  </div>
                </Button>
              </div>

              {/* Icon */}
              <div className="absolute top-2 right-2 md:top-1.5 md:right-1.5 text-xl md:text-lg filter drop-shadow-lg">
                {card.icon}
              </div>

              {/* Stack indicator for non-top cards */}
              {!isTop && (
                <div className="absolute inset-0 bg-black/10 rounded-2xl"></div>
              )}
            </div>
          </div>
        );
      })}
    </div>
  );
}
import { format } from "date-fns";

import { apiRequest } from "@/lib/queryClient";

import {

  LineChart,
  Line,
  AreaChart,
  Area,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  ResponsiveContainer,
  Tooltip,
  CartesianGrid,
  Pie,
  Cell,
  ReferenceLine,
} from "recharts";

function NiftyIndex() {
  const {
    data: marketData,
    isLoading,
    error,
  } = useQuery({
    queryKey: ["/api/market-data"],
    refetchInterval: 3000, // Refresh every 3 seconds for live data
  });

  if (isLoading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Activity className="h-5 w-5" />
            NIFTY 50 Index
          </CardTitle>
          <CardDescription>Live market data</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="animate-pulse">Loading...</div>
        </CardContent>
      </Card>
    );
  }

  if (error) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Activity className="h-5 w-5" />
            NIFTY 50 Index
          </CardTitle>
          <CardDescription>Live market data</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="text-red-500">Error loading data</div>
        </CardContent>
      </Card>
    );
  }

  // Find NIFTY50 data from the response
  const niftyData = Array.isArray(marketData)
    ? marketData.find((item: any) => item.symbol === "NIFTY50")
    : null;

  if (!niftyData) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Activity className="h-5 w-5" />
            NIFTY 50 Index
          </CardTitle>
          <CardDescription>Live market data</CardDescription>
        </CardHeader>
        <CardContent>
          <div>NIFTY data not available</div>
        </CardContent>
      </Card>
    );
  }

  const isPositive = niftyData.change >= 0;
  const TrendIcon = isPositive ? TrendingUp : TrendingDown;
  const trendColor = isPositive ? "text-green-600" : "text-red-600";

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Activity className="h-5 w-5" />
          {niftyData.name}
        </CardTitle>
        <CardDescription>Live streaming data from NSE</CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="grid grid-cols-2 gap-4">
          <div>
            <div className="text-2xl font-bold">
              {niftyData.ltp?.toLocaleString("en-IN", {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2,
              }) || "N/A"}
            </div>
            <div className="text-sm text-gray-500">Last Traded Price</div>
          </div>
          <div className={`text-right ${trendColor}`}>
            <div className="flex items-center justify-end gap-1">
              <TrendIcon className="h-4 w-4" />
              <span className="text-lg font-semibold">
                {isPositive ? "+" : ""}
                {niftyData.change?.toFixed(2) || "N/A"}
              </span>
            </div>
            <div className="text-sm">
              ({isPositive ? "+" : ""}
              {niftyData.changePercent?.toFixed(2) || "N/A"}%)
            </div>
          </div>
        </div>

        <div className="pt-4 border-t">
          <div className="text-xs text-gray-500">
            Last Updated: {new Date(niftyData.lastUpdate).toLocaleTimeString()}
          </div>
          <div className="text-xs text-gray-500">Code: {niftyData.code}</div>
        </div>
      </CardContent>
    </Card>
  );
}

interface HistoricalDataResponse {
  symbol: string;
  resolution: string;
  range_from: string;
  range_to: string;
  candles: Array<{
    timestamp: number;
    open: number;
    high: number;
    low: number;
    close: number;
    volume: number;
  }>;
}

function HistoricalDataSection() {
  // Set default dates to a few days ago to ensure data availability (avoid weekends/holidays)
  const defaultDate = new Date();
  defaultDate.setDate(defaultDate.getDate() - 3); // Go back 3 days to avoid weekend issues
  const [fromDate, setFromDate] = useState(format(defaultDate, "yyyy-MM-dd"));
  const [toDate, setToDate] = useState(format(defaultDate, "yyyy-MM-dd"));
  const [timeframe, setTimeframe] = useState("1");
  const [selectedSymbol, setSelectedSymbol] = useState("NSE:INFY-EQ");
  const [sentimentAnalysis, setSentimentAnalysis] = useState<any[]>([]);
  const [isAnalyzingSentiment, setIsAnalyzingSentiment] = useState(false);
  const queryClient = useQueryClient();

  const { data: historicalData } = useQuery<HistoricalDataResponse>({
    queryKey: [
      "/api/historical-data",
      selectedSymbol,
      fromDate,
      toDate,
      timeframe,
    ],
    enabled: true, // Enable automatic fetching
  });

  const fetchHistoricalData = useMutation({
    mutationFn: async () => {
      const response = await fetch(getFullApiUrl("/api/historical-data"), {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          symbol: selectedSymbol,
          resolution: timeframe,
          range_from: fromDate,
          range_to: toDate,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || "Failed to fetch historical data");
      }

      return response.json();
    },
    onSuccess: (data) => {
      queryClient.setQueryData(
        ["/api/historical-data", selectedSymbol, fromDate, toDate, timeframe],
        data,
      );
    },
  });

  const handleFetchData = () => {
    fetchHistoricalData.mutate();
  };

  const analyzeSentiment = async (candles: any[], symbol: string) => {
    if (!candles || candles.length === 0) return;

    setIsAnalyzingSentiment(true);
    try {
      const response = await fetch(getFullApiUrl("/api/sentiment-analysis"), {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          candles,
          symbol,
        }),
      });

      if (response.ok) {
        const data = await response.json();
        setSentimentAnalysis(data.sentiment || []);
      } else {
        console.error("Failed to analyze sentiment");
        setSentimentAnalysis([]);
      }
    } catch (error) {
      console.error("Sentiment analysis error:", error);
      setSentimentAnalysis([]);
    } finally {
      setIsAnalyzingSentiment(false);
    }
  };

  // Auto-analyze sentiment when historical data changes
  React.useEffect(() => {
    if (historicalData?.candles && historicalData.candles.length > 0) {
      analyzeSentiment(historicalData.candles, selectedSymbol);
    }
  }, [historicalData, selectedSymbol]);

  const handleExportToExcel = () => {
    if (
      !historicalData ||
      !historicalData.candles ||
      historicalData.candles.length === 0
    ) {
      return;
    }

    // Prepare CSV content with sentiment data
    const headers = [
      "Date",
      "Time",
      "Open",
      "High",
      "Low",
      "Close",
      "Volume",
      "Sentiment_Signal",
      "Sentiment_Score",
      "Confidence",
    ];
    const csvContent = [
      headers.join(","),
      ...historicalData.candles.map((candle, index) => {
        const date = new Date(candle.timestamp * 1000);
        const dateStr = format(date, "d/M/yyyy");
        const timeStr = format(date, "HH:mm:ss");
        const sentiment = sentimentAnalysis[index];
        return [
          dateStr,
          timeStr,
          candle.open.toFixed(2),
          candle.high.toFixed(2),
          candle.low.toFixed(2),
          candle.close.toFixed(2),
          candle.volume.toString(),
          sentiment?.signal || "N/A",
          sentiment?.score?.toFixed(2) || "N/A",
          sentiment?.confidence?.toFixed(0) || "N/A",
        ].join(",");
      }),
    ].join("\n");

    // Create and download file
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);

    // Generate filename with symbol, timeframe, and date range
    const symbolName = (selectedSymbol || "UNKNOWN")
      .replace("NSE:", "")
      .replace("-EQ", "")
      .replace("-INDEX", "");
    const timeframeName = timeframe === "1" ? "1min" : `${timeframe}min`;
    const dateRange =
      fromDate === toDate ? fromDate : `${fromDate}_to_${toDate}`;
    const filename = `${symbolName}_${timeframeName}_${dateRange}_OHLC.csv`;

    link.setAttribute("download", filename);
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <BarChart3 className="h-5 w-5" />
          Historical OHLC Data
        </CardTitle>
        <CardDescription>
          Custom date range, symbol, and timeframe selection with real-time
          Fyers API data
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-6">
        {/* Date, Symbol, and Timeframe Selection */}
        <div className="grid grid-cols-1 md:grid-cols-5 gap-4">
          <div className="space-y-2">
            <Label htmlFor="from-date">From Date</Label>
            <Input
              id="from-date"
              type="date"
              value={fromDate}
              onChange={(e) => setFromDate(e.target.value)}
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="to-date">To Date</Label>
            <Input
              id="to-date"
              type="date"
              value={toDate}
              onChange={(e) => setToDate(e.target.value)}
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="symbol">Symbol</Label>
            <Select value={selectedSymbol} onValueChange={setSelectedSymbol}>
              <SelectTrigger>
                <SelectValue placeholder="Select symbol" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="NSE:NIFTY50-INDEX">NIFTY 50</SelectItem>
                <SelectItem value="NSE:INFY-EQ">INFOSYS</SelectItem>
                <SelectItem value="NSE:RELIANCE-EQ">RELIANCE</SelectItem>
                <SelectItem value="NSE:TCS-EQ">TCS</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <div className="space-y-2">
            <Label htmlFor="timeframe">Timeframe</Label>
            <Select value={timeframe} onValueChange={setTimeframe}>
              <SelectTrigger>
                <SelectValue placeholder="Select timeframe" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="1">1 Minute</SelectItem>
                <SelectItem value="5">5 Minutes</SelectItem>
                <SelectItem value="10">10 Minutes</SelectItem>
                <SelectItem value="15">15 Minutes</SelectItem>
                <SelectItem value="20">20 Minutes</SelectItem>
                <SelectItem value="30">30 Minutes</SelectItem>
                <SelectItem value="40">40 Minutes</SelectItem>
                <SelectItem value="60">1 Hour</SelectItem>
                <SelectItem value="80">80 Minutes</SelectItem>
                <SelectItem value="120">2 Hours</SelectItem>
                <SelectItem value="160">160 Minutes</SelectItem>
                <SelectItem value="240">4 Hours</SelectItem>
                <SelectItem value="320">320 Minutes</SelectItem>
                <SelectItem value="480">8 Hours</SelectItem>
                <SelectItem value="960">16 Hours</SelectItem>
                <SelectItem value="1D">1 Day</SelectItem>
                <SelectItem value="2D">2 Days</SelectItem>
                <SelectItem value="4D">4 Days</SelectItem>
                <SelectItem value="8D">8 Days</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <div className="space-y-2">
            <Label>&nbsp;</Label>
            <div className="flex gap-1.5">
              <Button
                onClick={handleFetchData}
                disabled={fetchHistoricalData.isPending}
                className="flex-1"
              >
                <Calendar className="h-4 w-4 mr-2" />
                {fetchHistoricalData.isPending ? "Fetching..." : "Fetch Data"}
              </Button>
              <Button
                onClick={handleExportToExcel}
                disabled={
                  !historicalData || historicalData.candles.length === 0
                }
                variant="outline"
                size="default"
                className="px-3"
                title="Export OHLC data to Excel"
              >
                <Download className="h-4 w-4" />
              </Button>
            </div>
          </div>
        </div>

        {/* Results Display */}
        {fetchHistoricalData.isError && (
          <div className="p-4 bg-red-50 border border-red-200 rounded-lg">
            <div className="flex items-start space-x-3">
              <div className="bg-red-100 rounded-full p-1">
                <svg
                  className="h-5 w-5 text-red-600"
                  fill="currentColor"
                  viewBox="0 0 20 20"
                >
                  <path
                    fillRule="evenodd"
                    d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z"
                    clipRule="evenodd"
                  />
                </svg>
              </div>
              <div className="flex-1">
                <h3 className="text-red-800 font-medium">
                  Fyers API Temporary Service Issue
                </h3>
                <div className="text-red-700 text-sm mt-1 space-y-2">
                  <p>
                    <strong>Current Status:</strong> Fyers API is experiencing
                    intermittent service issues with historical data endpoints.
                    Live market data continues working perfectly.
                  </p>
                  <div className="bg-green-100 p-3 rounded border-l-4 border-green-400">
                    <p className="font-medium text-green-800">
                      What's Still Working:
                    </p>
                    <ul className="mt-1 space-y-1 text-xs text-green-700">
                      <li>
                        • <strong>Live Market Data:</strong> Real-time prices
                        streaming every 3 seconds (Dashboard tab)
                      </li>
                      <li>
                        • <strong>Chart Tab:</strong> Professional interactive
                        candlestick chart with zoom controls
                      </li>
                      <li>
                        • <strong>Pattern Analysis:</strong> All 14 Battu API
                        endpoints for technical analysis
                      </li>
                      <li>
                        • <strong>Previously Successful:</strong> CB Tab fetched
                        375 candles earlier before API maintenance
                      </li>
                    </ul>
                  </div>
                  <div className="bg-blue-100 p-3 rounded border-l-4 border-blue-400">
                    <p className="font-medium text-blue-800">
                      Alternative Solutions:
                    </p>
                    <ul className="mt-1 space-y-1 text-xs text-blue-700">
                      <li>
                        • <strong>Use Chart Tab:</strong> Interactive
                        candlestick chart may have different data endpoints
                      </li>
                      <li>
                        • <strong>Try Later:</strong> API maintenance typically
                        resolves within 30-60 minutes
                      </li>
                      <li>
                        • <strong>Different Dates:</strong> Try various past
                        trading days as availability varies
                      </li>
                      <li>
                        • <strong>Monitor Dashboard:</strong> Live streaming
                        data remains fully functional
                      </li>
                    </ul>
                  </div>
                </div>
              </div>
            </div>
          </div>
        )}

        {historicalData && (
          <div className="space-y-4">
            <div className="p-3 bg-green-50 border border-green-200 rounded-lg mb-4">
              <div className="flex items-center space-x-2">
                <div className="bg-green-100 rounded-full p-1">
                  <svg
                    className="h-4 w-4 text-green-600"
                    fill="currentColor"
                    viewBox="0 0 20 20"
                  >
                    <path
                      fillRule="evenodd"
                      d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
                      clipRule="evenodd"
                    />
                  </svg>
                </div>
                <div className="text-green-800 font-medium">
                  ✅ Fyers API Successfully Connected & Data Loaded!
                </div>
              </div>
              <div className="text-green-700 text-sm mt-1">
                Real-time historical OHLC data fetched successfully from Fyers
                API v3.0.0
              </div>
            </div>
            <div className="flex items-center justify-between">
              <h3 className="text-lg font-semibold">
                OHLC Data ({historicalData?.candles?.length || 0} candles) - CB
                Tab
              </h3>
              <div className="text-sm text-gray-500 space-y-1">
                <div>
                  {fromDate} to {toDate} | {timeframe} minute timeframe
                </div>
                <div className="text-xs">
                  Total Candles: {historicalData?.candles?.length || 0}
                </div>
              </div>
            </div>

            <div className="max-h-96 overflow-auto border rounded-lg custom-thin-scrollbar">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Date/Time</TableHead>
                    <TableHead className="text-right">Open</TableHead>
                    <TableHead className="text-right">High</TableHead>
                    <TableHead className="text-right">Low</TableHead>
                    <TableHead className="text-right">Close</TableHead>
                    <TableHead className="text-right">Volume</TableHead>
                    <TableHead className="text-center">Sentiment</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {historicalData?.candles?.map((candle, index) => (
                    <TableRow key={index}>
                      <TableCell className="font-medium">
                        {new Date(candle.timestamp * 1000).toLocaleString()}
                      </TableCell>
                      <TableCell className="text-right">
                        {candle.open.toFixed(2)}
                      </TableCell>
                      <TableCell className="text-right">
                        {candle.high.toFixed(2)}
                      </TableCell>
                      <TableCell className="text-right">
                        {candle.low.toFixed(2)}
                      </TableCell>
                      <TableCell className="text-right">
                        {candle.close.toFixed(2)}
                      </TableCell>
                      <TableCell className="text-right">
                        {candle.volume.toLocaleString()}
                      </TableCell>
                      <TableCell className="text-center">
                        {isAnalyzingSentiment &&
                        index < sentimentAnalysis.length ? (
                          <div className="flex items-center justify-center space-x-1">
                            <div className="animate-spin rounded-full h-3 w-3 border-b-2 border-blue-600"></div>
                            <span className="text-xs text-gray-500">
                              Analyzing...
                            </span>
                          </div>
                        ) : sentimentAnalysis[index] ? (
                          <div className="space-y-1 bg-white dark:bg-gray-900/50 rounded-lg p-3">
                            <div
                              className={`text-xs font-semibold px-2 py-1 rounded ${
                                sentimentAnalysis[index].signal === "BUY"
                                  ? "bg-green-100 text-green-800"
                                  : sentimentAnalysis[index].signal === "SELL"
                                    ? "bg-red-100 text-red-800"
                                    : "bg-gray-100 text-gray-800"
                              }`}
                            >
                              {sentimentAnalysis[index].signal}
                            </div>
                            <div className="text-xs text-gray-600">
                              {sentimentAnalysis[index].confidence}%
                            </div>
                            <div className="w-full bg-gray-200 rounded-full h-1">
                              <div
                                className={`h-1 rounded-full ${
                                  sentimentAnalysis[index].score > 0
                                    ? "bg-green-500"
                                    : "bg-red-500"
                                }`}
                                style={{
                                  width: `${
                                    Math.abs(sentimentAnalysis[index].score) *
                                    100
                                  }%`,
                                }}
                              ></div>
                            </div>
                          </div>
                        ) : (
                          <span className="text-xs text-gray-400">-</span>
                        )}
                      </TableCell>
                    </TableRow>
                  ))}
                  {(!historicalData?.candles ||
                    historicalData.candles.length === 0) && (
                    <TableRow>
                      <TableCell
                        colSpan={7}
                        className="text-center text-gray-500"
                      >
                        <div className="space-y-2">
                          <div>No historical data available</div>
                          <div className="text-sm">
                            Historical data access may require specific API
                            permissions or market hours. Use the "Fetch Data"
                            button above to attempt loading data.
                          </div>
                        </div>
                      </TableCell>
                    </TableRow>
                  )}
                </TableBody>
              </Table>
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
}

function MicroAnimationsDemoPage() {
  const [demoPrice, setDemoPrice] = useState(1552.5);
  const [prevPrice, setPrevPrice] = useState(1552.5);
  const [isExecuting, setIsExecuting] = useState(false);
  const [tradeType, setTradeType] = useState<"buy" | "sell">("buy");
  const [volume, setVolume] = useState(1000000);
  const [isLive, setIsLive] = useState(true);
  const [profitLoss, setProfitLoss] = useState(0);
  const [showCandleAnimation, setShowCandleAnimation] = useState(false);

  // Demo candle data
  const demoCandleData = {
    open: 1580.0,
    high: 1585.5,
    low: 1548.2,
    close: 1552.5,
  };

  const updatePrice = (direction: "up" | "down") => {
    setPrevPrice(demoPrice);
    const change =
      direction === "up" ? Math.random() * 5 + 1 : -(Math.random() * 5 + 1);
    setDemoPrice((prev) => Math.max(prev + change, 1500));
  };

  const simulateTradeExecution = () => {
    setIsExecuting(true);
    setTimeout(() => {
      setIsExecuting(false);
      const change =
        tradeType === "buy"
          ? Math.random() * 10 + 5
          : -(Math.random() * 10 + 5);
      setProfitLoss(change);
    }, 3000);
  };

  const simulateVolumeSpike = () => {
    setVolume((prev) => prev * (1.5 + Math.random()));
    setTimeout(() => setVolume(1000000), 3000);
  };

  const toggleMarketStatus = () => {
    setIsLive(!isLive);
  };

  const triggerCandleAnimation = () => {
    setShowCandleAnimation(false);
    setTimeout(() => setShowCandleAnimation(true), 100);
  };

  return (
    <div className="max-w-7xl mx-auto space-y-8">
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Zap className="h-5 w-5" />
            Micro-Animations for Trading Interface
          </CardTitle>
          <CardDescription>
            Interactive demos showcasing smooth animations for trade execution
            and market movements
          </CardDescription>
        </CardHeader>
      </Card>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        {/* Price Change Animation */}
        <Card>
          <CardHeader>
            <CardTitle>Price Change Animation</CardTitle>
            <CardDescription>
              Live price updates with directional indicators
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center justify-center p-6 bg-gray-50 dark:bg-white dark:bg-gray-900 rounded-lg">
              <PriceChangeAnimation
                value={demoPrice}
                previousValue={prevPrice}
                className="text-lg"
              />
            </div>
            <div className="flex gap-1.5">
              <Button onClick={() => updatePrice("up")} className="flex-1">
                <TrendingUp className="h-4 w-4 mr-2" />
                Price Up
              </Button>
              <Button
                onClick={() => updatePrice("down")}
                variant="outline"
                className="flex-1"
              >
                <TrendingDown className="h-4 w-4 mr-2" />
                Price Down
              </Button>
            </div>
          </CardContent>
        </Card>

        {/* Trade Execution Animation */}
        <Card>
          <CardHeader>
            <CardTitle>Trade Execution Animation</CardTitle>
            <CardDescription>
              Order execution feedback with loading states
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-1">
              <div className="flex gap-1.5">
                <Button
                  onClick={() => setTradeType("buy")}
                  variant={tradeType === "buy" ? "default" : "outline"}
                  size="sm"
                >
                  Buy
                </Button>
                <Button
                  onClick={() => setTradeType("sell")}
                  variant={tradeType === "sell" ? "default" : "outline"}
                  size="sm"
                >
                  Sell
                </Button>
              </div>
              <Button
                onClick={simulateTradeExecution}
                disabled={isExecuting}
                className="w-full"
              >
                {isExecuting ? (
                  <>
                    <Activity className="h-4 w-4 mr-2 animate-spin" />
                    Executing...
                  </>
                ) : (
                  <>
                    <Play className="h-4 w-4 mr-2" />
                    Execute {tradeType.toUpperCase()} Order
                  </>
                )}
              </Button>
            </div>
            <TradeExecutionAnimation
              isExecuting={isExecuting}
              tradeType={tradeType}
              amount="100"
              symbol="INFY"
            />
          </CardContent>
        </Card>

        {/* Volume Spike Animation */}
        <Card>
          <CardHeader>
            <CardTitle>Volume Spike Animation</CardTitle>
            <CardDescription>
              Animated volume alerts and notifications
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center justify-center p-6 bg-gray-50 dark:bg-gray-900 rounded-lg">
              <VolumeSpikeAnimation
                volume={volume}
                averageVolume={1000000}
                className="text-sm"
              />
            </div>
            <Button onClick={simulateVolumeSpike} className="w-full">
              <Zap className="h-4 w-4 mr-2" />
              Trigger Volume Spike
            </Button>
          </CardContent>
        </Card>

        {/* Market Status Pulse */}
        <Card>
          <CardHeader>
            <CardTitle>Market Status Animation</CardTitle>
            <CardDescription>
              Live market status with pulsing indicators
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center justify-center p-6 bg-gray-50 dark:bg-gray-900 rounded-lg">
              <MarketStatusPulse isLive={isLive} />
            </div>
            <Button onClick={toggleMarketStatus} className="w-full">
              <RotateCcw className="h-4 w-4 mr-2" />
              Toggle Market Status
            </Button>
          </CardContent>
        </Card>

        {/* Profit/Loss Animation */}
        <Card>
          <CardHeader>
            <CardTitle>Profit/Loss Animation</CardTitle>
            <CardDescription>
              Animated P&L with color transitions
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center justify-center p-6 bg-gray-50 dark:bg-gray-900 rounded-lg">
              <ProfitLossAnimation
                value={profitLoss}
                showCurrency={true}
                className="text-lg"
              />
            </div>
            <div className="grid grid-cols-2 gap-2">
              <Button
                onClick={() => setProfitLoss(Math.random() * 100 + 10)}
                size="sm"
              >
                <TrendingUp className="h-3 w-3 mr-1" />
                Profit
              </Button>
              <Button
                onClick={() => setProfitLoss(-(Math.random() * 100 + 10))}
                variant="outline"
                size="sm"
              >
                <TrendingDown className="h-3 w-3 mr-1" />
                Loss
              </Button>
            </div>
          </CardContent>
        </Card>

        {/* Candlestick Animation */}
        <Card>
          <CardHeader>
            <CardTitle>Candlestick Formation</CardTitle>
            <CardDescription>Animated candle drawing process</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center justify-center p-6 bg-gray-50 dark:bg-gray-900 rounded-lg">
              {showCandleAnimation && (
                <CandlestickAnimation candle={demoCandleData} duration={2000} />
              )}
            </div>
            <Button onClick={triggerCandleAnimation} className="w-full">
              <BarChart3 className="h-4 w-4 mr-2" />
              Animate Candle Formation
            </Button>
          </CardContent>
        </Card>
      </div>

      {/* Loading Skeleton Demo */}
      <Card>
        <CardHeader>
          <CardTitle>Market Data Loading Animation</CardTitle>
          <CardDescription>
            Skeleton loading states for market data
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            <MarketDataSkeleton />
            <MarketDataSkeleton />
            <MarketDataSkeleton />
          </div>
        </CardContent>
      </Card>

      {/* Integration Examples */}
      <Card>
        <CardHeader>
          <CardTitle>Live Market Data with Animations</CardTitle>
          <CardDescription>
            Real INFY data enhanced with micro-animations
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div className="space-y-2">
              <Label>Live Price</Label>
              <PriceChangeAnimation
                value={1552.5}
                previousValue={1574.5}
                className="p-3 border rounded-lg bg-white dark:bg-gray-700"
              />
            </div>
            <div className="space-y-2">
              <Label>P&L Today</Label>
              <ProfitLossAnimation
                value={-22.0}
                showCurrency={true}
                className="p-3 border rounded-lg bg-white dark:bg-gray-700"
              />
            </div>
            <div className="space-y-2">
              <Label>Market Status</Label>
              {isReportLoading && (
                                                  <div className="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 rounded-lg">
                                                    <div className="bg-gradient-to-br from-gray-800 to-gray-900 rounded-lg p-8 border border-gray-700 shadow-2xl max-w-md">
                                                      <div className="text-center">
                                                        <style>{`
                                                          @keyframes thinkingDot {
                                                            0%, 60%, 100% { opacity: 0.3; transform: translateY(0); }
                                                            30% { opacity: 1; transform: translateY(-8px); }
                                                          }
                                                          .thinking-dot {
                                                            display: inline-block;
                                                            width: 10px;
                                                            height: 10px;
                                                            border-radius: 50%;
                                                            background-color: #3b82f6;
                                                            animation: thinkingDot 1.4s infinite;
                                                            margin: 0 4px;
                                                          }
                                                          .thinking-dot:nth-child(2) { animation-delay: 0.2s; }
                                                          .thinking-dot:nth-child(3) { animation-delay: 0.4s; }
                                                        `}</style>
                                                        <h3 className="text-lg font-semibold text-white mb-4">Generating Financial Report</h3>
                                                        <div className="flex items-center justify-center gap-2 mb-3">
                                                          <div className="thinking-dot"></div>
                                                          <div className="thinking-dot"></div>
                                                          <div className="thinking-dot"></div>
                                                        </div>
                                                        <p className="text-sm text-gray-400">Analyzing quarterly data, company insights, and financial statements...</p>
                                                      </div>
                                                    </div>
                                                  </div>
                                                )}
                                                <div className="p-3 border rounded-lg bg-white dark:bg-gray-700">
                <MarketStatusPulse isLive={false} />
              </div>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

// API base URL for Cloud Run compatibility - use environment variable
// BUT: In development mode (localhost), always use relative URLs to avoid CORS issues
const isDevelopmentMode = window.location.hostname === 'localhost' || 
                          window.location.hostname === '127.0.0.1' ||
                          window.location.hostname.includes('replit.dev') ||
                          window.location.port === '5000';

const API_BASE_URL = isDevelopmentMode ? '' : (import.meta.env.VITE_API_URL || '');

// Helper function to construct full API URLs for Cloud Run compatibility
const getFullApiUrl = (path: string): string => {
  if (path.startsWith('http')) return path;
  return `${API_BASE_URL}${path}`;
};

export default function Home() {
  const [location, setLocation] = useLocation();

  // 🔶 Detect Angel One OAuth callback from redirect
  React.useEffect(() => {
    const params = new URLSearchParams(window.location.search);
    if (params.has("angelone_connected")) {
      console.log("✅ Angel One connected successfully (redirect callback)");
      setAngelOneIsConnected(true);
      setAngelOneAccessToken(params.get("angelone_client_code") || "P176266");
      localStorage.setItem("angel_one_client_code", params.get("angelone_client_code") || "P176266");
      toast({ title: "Success", description: "Angel One connected successfully" });
      window.history.replaceState({}, document.title, window.location.pathname);
    }
    if (params.has("angelone_error")) {
      const error = decodeURIComponent(params.get("angelone_error") || "");
      console.error("❌ Angel One auth error:", error);
      toast({ variant: "destructive", title: "Error", description: error });
      window.history.replaceState({}, document.title, window.location.pathname);
    }
  }, []);
  // AUTO-CONNECT: Angel One API - Automatically connect when app loads
  useAngelOneAutoconnect();
  const { theme, toggleTheme } = useTheme();
  const [activeTab, setActiveTab] = useState("trading-home");
  const [showTutorOverlay, setShowTutorOverlay] = useState(false);
  const [swipeStartY, setSwipeStartY] = useState(0);
  const [swipeCurrentY, setSwipeCurrentY] = useState(0);
  const [isSwipingUp, setIsSwipingUp] = useState(false);
  const [showJournalAI, setShowJournalAI] = useState(false);
  const [journalAIData, setJournalAIData] = useState<any>(null);
  const [statisticsTab, setStatisticsTab] = useState("overview");
  // Shared timeframe state for chart and crossings display
  const [chartTimeframe, setChartTimeframe] = useState<string>("1");
  const [isEditingUsername, setIsEditingUsername] = useState(false);
  const [isEditingDisplayName, setIsEditingDisplayName] = useState(false);
  const [newDisplayName, setNewDisplayName] = useState("");
  const [isEditingDob, setIsEditingDob] = useState(false);
  const [newDob, setNewDob] = useState("");
  const [isEditingLocation, setIsEditingLocation] = useState(false);
  const [newLocation, setNewLocation] = useState("");
  const [newUsername, setNewUsername] = useState("");
  const [isUsernameAvailable, setIsUsernameAvailable] = useState<boolean | null>(null);
  const [isCheckingUsername, setIsCheckingUsername] = useState(false);
  // Navigation menu state
  const [isNavOpen, setIsNavOpen] = useState(false);
  const [isProfileActive, setIsProfileActive] = useState(false);

  const handleUpdateProfile = async (updates: any) => {
    try {
      const token = await getCognitoToken();
      const response = await fetch("/api/user/profile", {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`
        },
        body: JSON.stringify(updates),
      });
      if (response.ok) {
        toast({ description: "Profile updated successfully" });
        window.location.reload();
      } else {
        throw new Error("Failed to update profile");
      }
    } catch (error) {
      console.error("Profile update error:", error);
      toast({ description: "Error updating profile", variant: "destructive" });
    }
  };

  // Mobile bottom navigation state (home, insight, ranking, paper-trade)
  const [mobileBottomTab, setMobileBottomTab] = useState<
    "home" | "insight" | "ranking" | "paper-trade"
  >("home");
  // Settings panel state
  const [showSettingsPanel, setShowSettingsPanel] = useState(false);
  const [emailVerified, setEmailVerified] = useState<boolean | null>(null);
  const [verificationOtp, setVerificationOtp] = useState("");
  const [verificationSending, setVerificationSending] = useState(false);
  const [verificationConfirming, setVerificationConfirming] = useState(false);
  const [verificationCodeSent, setVerificationCodeSent] = useState(false);
  const [verificationError, setVerificationError] = useState("");

  // Clear old localStorage data - using AWS only now
  useEffect(() => {
    localStorage.removeItem("tradingDataByDate");
    console.log("🧹 Cleared old localStorage tradingDataByDate - using AWS only");
  }, []);

  // Auth state initialization - wait for AWS to sync
  const [authInitialized, setAuthInitialized] = useState(false);
  // View-only mode for unauthenticated users - they can view but not interact with protected features
  const [isViewOnlyMode, setIsViewOnlyMode] = useState(false);
  const [selectedAudioTrack, setSelectedAudioTrack] = useState<{title: string, duration: string, id: string, youtubeId: string} | null>({ title: 'Bruce Lee: "Your Greatest Enemy Is Within"', duration: "22:30", id: "p1", youtubeId: "KnppzfiZcgM" });
  const [audioProgress, setAudioProgress] = useState(0);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [isAudioPlaying, setIsAudioPlaying] = useState(false);
  const youtubePlayerRef = useRef<any>(null);

  useEffect(() => {
    const tag = document.createElement("script");
    tag.src = "https://www.youtube.com/iframe_api";
    const firstScriptTag = document.getElementsByTagName("script")[0];
    firstScriptTag.parentNode?.insertBefore(tag, firstScriptTag);

    (window as any).onYouTubeIframeAPIReady = () => {
      console.log("📺 YouTube IFrame API Ready");
    };
  }, []);

  useEffect(() => {
    if (selectedAudioTrack?.youtubeId) {
      if (youtubePlayerRef.current) {
        youtubePlayerRef.current.destroy();
      }

      const playerContainer = document.getElementById("youtube-audio-player");
      if (playerContainer) {
        youtubePlayerRef.current = new (window as any).YT.Player("youtube-audio-player", {
          height: "0",
          width: "0",
          videoId: selectedAudioTrack.youtubeId,
          playerVars: {
            autoplay: 1,
            controls: 0,
            showinfo: 0,
            modestbranding: 1,
            loop: 1,
            fs: 0,
            cc_load_policy: 0,
            iv_load_policy: 3,
            autohide: 0
          },
          events: {
            onReady: (event: any) => {
              setDuration(event.target.getDuration());
              const interval = setInterval(() => {
                if (youtubePlayerRef.current && youtubePlayerRef.current.getCurrentTime) {
                  const time = youtubePlayerRef.current.getCurrentTime();
                  setCurrentTime(time);
                  if (youtubePlayerRef.current.getDuration) {
                    const dur = youtubePlayerRef.current.getDuration();
                    setDuration(dur);
                    setAudioProgress((time / dur) * 100);
                  }
                }
              }, 1000);
              console.log("🎵 YouTube Audio Ready");
              event.target.playVideo();
              setIsAudioPlaying(true);
            },
            onStateChange: (event: any) => {
              if (event.data === (window as any).YT.PlayerState.ENDED) {
                event.target.playVideo();
              }
            }
          }
        });
      }
    }
  }, [selectedAudioTrack]);

  useEffect(() => {
    if (youtubePlayerRef.current) {
      if (isAudioPlaying) {
        youtubePlayerRef.current.playVideo();
      } else {
        youtubePlayerRef.current.pauseVideo();
      }
    }
  }, [isAudioPlaying]);

  // Get current user data from AWS DynamoDB
  const { currentUser } = useCurrentUser();

  // Initialize AWS auth sync with localStorage - NO AUTOMATIC REDIRECT
  // Users can view the home screen, redirect only happens when they try to interact with protected content
  useEffect(() => {
    const userId = localStorage.getItem('currentUserId');
    const userEmail = localStorage.getItem('currentUserEmail');

    if (userId && userEmail && userId !== 'null' && userEmail !== 'null') {
      console.log('✅ Auth initialized from localStorage:', { userId, userEmail });
      setAuthInitialized(true);
      setIsViewOnlyMode(false);
    } else {
      // Wait for AWS auth state with timeout - but DON'T redirect, just enable view-only mode
      const timer = setTimeout(() => {
        const finalUserId = localStorage.getItem('currentUserId');
        const finalUserEmail = localStorage.getItem('currentUserEmail');

        if (!finalUserId || !finalUserEmail || finalUserId === 'null' || finalUserEmail === 'null') {
          console.log('🎯 No auth found - enabling view-only mode (no redirect)');
          setIsViewOnlyMode(true);
          setAuthInitialized(true); // Mark as initialized so UI renders
        } else {
          console.log('✅ Auth initialized after delay:', { finalUserId, finalUserEmail });
          setAuthInitialized(true);
          setIsViewOnlyMode(false);
        }
      }, 500); // Use AWS Cognito for authentication sync

      return () => clearTimeout(timer);
    }
  }, []);

  // AI Search state

  // Check email verification status when settings panel opens
  useEffect(() => {
    if (showSettingsPanel && currentUser) {
      checkEmailVerified().then((verified) => {
        setEmailVerified(verified);
      }).catch(() => {
        setEmailVerified(false);
      });
    }
  }, [showSettingsPanel, currentUser]);

  // Handle sending verification OTP
  const handleSendVerificationOtp = async () => {
    setVerificationSending(true);
    setVerificationError("");
    try {
      await sendEmailVerificationCode();
      setVerificationCodeSent(true);
    } catch (error: any) {
      setVerificationError(error?.message || "Failed to send verification code");
    } finally {
      setVerificationSending(false);
    }
  };

  // Handle confirming email verification
  const handleConfirmVerification = async () => {
    if (!verificationOtp || verificationOtp.length !== 6) {
      setVerificationError("Please enter a valid 6-digit code");
      return;
    }
    setVerificationConfirming(true);
    setVerificationError("");
    try {
      await confirmEmailVerification(verificationOtp);
      setEmailVerified(true);
      setVerificationCodeSent(false);
      setVerificationOtp("");
    } catch (error: any) {
      if (error?.name === "CodeMismatchException") {
        setVerificationError("Invalid verification code. Please try again.");
      } else if (error?.name === "ExpiredCodeException") {
        setVerificationError("Code expired. Please request a new one.");
      } else {
        setVerificationError(error?.message || "Verification failed");
      }
    } finally {
      setVerificationConfirming(false);
    }
  };
  const [searchQuery, setSearchQuery] = useState("");
  const [isSearchActive, setIsSearchActive] = useState(false);
  const [searchResults, setSearchResults] = useState("");
  const [isSearchLoading, setIsSearchLoading] = useState(false);
  const [isReportLoading, setIsReportLoading] = useState(false);
  const [isWatchlistLoading, setIsWatchlistLoading] = useState(false);
  const [searchResultsNews, setSearchResultsNews] = useState<any[]>([]);
  const [searchResultsNewsSymbol, setSearchResultsNewsSymbol] = useState("");
  const [aiChartSelectedTimeframe, setAiChartSelectedTimeframe] = useState('1Y');

  // Listen for timeframe change events to trigger re-render
  useEffect(() => {
    const handleTimeframeChange = () => {
      const newTimeframe = (window as any).aiAssistantSelectedTimeframe || '1Y';
      setAiChartSelectedTimeframe(newTimeframe);
    };

    window.addEventListener('timeframeChange', handleTimeframeChange);
    return () => window.removeEventListener('timeframeChange', handleTimeframeChange);
  }, []);

  // Fetch news for search results when symbol changes (use same source as chart: window.companyInsightsData)
  useEffect(() => {
    if (!searchResults || !isSearchActive) return;

    // Get symbol from the same source the chart uses
    const companyInsights = (window as any).companyInsightsData;
    const stockData = (window as any).aiAssistantStockData;

    // Extract symbol: prefer companyInsightsData.symbol, fallback to aiAssistantStockData.name
    let currentSymbol = companyInsights?.symbol || '';
    if (!currentSymbol && stockData?.name) {
      // Extract symbol from stock name (format: "RELIANCE\nReliance Industries")
      currentSymbol = stockData.name.split('\n')[0]?.trim() || '';
    }

    if (!currentSymbol || currentSymbol === searchResultsNewsSymbol) return;

    console.log('📰 Fetching news for search results symbol:', currentSymbol);
    setSearchResultsNewsSymbol(currentSymbol);
    setSearchResultsNews([]);

    (async () => {
      try {
        const response = await fetch(`/api/stock-news/${encodeURIComponent(currentSymbol.toUpperCase())}?refresh=${Date.now()}`);
        const data = await response.json();

        const articles = Array.isArray(data) ? data : (data.articles || data.data || []);

        if (articles && articles.length > 0) {
          const getRelativeTime = (dateString: string) => {
            try {
              const date = new Date(dateString);
              const now = new Date();
              const diffMs = now.getTime() - date.getTime();
              const diffSecs = Math.floor(diffMs / 1000);
              const diffMins = Math.floor(diffSecs / 60);
              const diffHours = Math.floor(diffMins / 60);
              const diffDays = Math.floor(diffHours / 24);
              const diffWeeks = Math.floor(diffDays / 7);

              if (diffSecs < 60) return 'Just now';
              if (diffMins < 60) return `${diffMins}m ago`;
              if (diffHours < 24) return `${diffHours}h ago`;
              if (diffDays < 7) return `${diffDays}d ago`;
              if (diffWeeks < 4) return `${diffWeeks}w ago`;
              return 'Recently';
            } catch (error) {
              return 'Recently';
            }
          };

          const formattedNews = articles.map((article: any) => ({
            title: article.title,
            source: article.source || "Market News",
            time: getRelativeTime(article.publishedAt || article.date || new Date().toISOString()),
            url: article.url || article.link || '#'
          }));

          console.log('📰 News fetched successfully:', formattedNews.length, 'articles');
          setSearchResultsNews(formattedNews);
        } else {
          console.log('📰 No news articles found for:', currentSymbol);
        }
      } catch (error) {
        console.warn("Failed to fetch news for symbol:", currentSymbol, error);
      }
    })();
  }, [searchResults, isSearchActive]);

  // ❌ REMOVED: journalSelectedDate - manual search chart is now completely standalone

  // Trending podcasts state
  const [selectedSector, setSelectedSector] = useState<string>("FINANCE");
  const [trendingPodcasts, setTrendingPodcasts] = useState<any[]>([]);
  const [isPodcastsLoading, setIsPodcastsLoading] = useState(false);
  const [selectedPodcast, setSelectedPodcast] = useState<any>(null);
  const [currentCardIndex, setCurrentCardIndex] = useState<number>(0);

  // Animated greeting stocks state
  const [currentStockIndex, setCurrentStockIndex] = useState(0);
  const [showingInitialGreeting, setShowingInitialGreeting] = useState(true);
  const animatedStocks = [
    { symbol: "NIFTY", price: "59273.80", change: +1.24, isProfit: true },
    { symbol: "BANKNIFTY", price: "52841.35", change: +0.87, isProfit: true },
    { symbol: "SENSEX", price: "85138.27", change: -0.45, isProfit: false },
    { symbol: "Top Gainers", price: "TCS +2.1%", change: +2.1, isProfit: true },
    { symbol: "Top Losers", price: "SUNPHARMA -1.8%", change: -1.8, isProfit: false },
  ];

  // Passcode protection state
  const [showPasscodeModal, setShowPasscodeModal] = useState(false);
  const [passcodeInput, setPasscodeInput] = useState("");
  const [authenticatedTabs, setAuthenticatedTabs] = useState<Set<string>>(
    new Set(),
  );
  const [pendingTab, setPendingTab] = useState<string>("");
  const [showSavedFormatsDropdown, setShowSavedFormatsDropdown] = useState(false);

  // Show initial greeting for 2 seconds, then switch to animated stocks
  useEffect(() => {
    if (!isViewOnlyMode) {
      const initialTimer = setTimeout(() => {
        setShowingInitialGreeting(false);
      }, 2000);
      return () => clearTimeout(initialTimer);
    }
  }, [isViewOnlyMode]);

  // Auto-rotate stock display every 3 seconds (only after initial greeting)
  useEffect(() => {
    if (!isViewOnlyMode && !showingInitialGreeting) {
      const interval = setInterval(() => {
        setCurrentStockIndex(prev => (prev + 1) % animatedStocks.length);
      }, 3000);
      return () => clearInterval(interval);
    }
  }, [animatedStocks.length, isViewOnlyMode, showingInitialGreeting]);

  // Expose toggle nav function to window for profile icon in right sidebar
  useEffect(() => {
    window.toggleNav = () => {
      setIsNavOpen(prev => !prev);
    };
    return () => {
      delete window.toggleNav;
    };
  }, []);

  // Passcode verification functions
  const protectedTabs = [
    "trading-home",
    "dashboard",
    "backtest",
  ]; // Protected tabs

  const handleTabClick = (tabName: string) => {
    if (protectedTabs.includes(tabName) && !authenticatedTabs.has(tabName)) {
      setPendingTab(tabName);
      setShowPasscodeModal(true);
    } else {
      setTabWithAuthCheck(tabName);
    }
  };

  const handlePasscodeSubmit = () => {
    if (passcodeInput === "1302") {
      const newAuthenticatedTabs = new Set(authenticatedTabs);
      newAuthenticatedTabs.add(pendingTab);
      setAuthenticatedTabs(newAuthenticatedTabs);
      setTabWithAuthCheck(pendingTab);
      setShowPasscodeModal(false);
      setPasscodeInput("");
      setPendingTab("");
    } else {
      // Reset on wrong passcode
      setPasscodeInput("");
    }
  };

  const handlePasscodeCancel = () => {
    setShowPasscodeModal(false);
    setPasscodeInput("");
    setPendingTab("");
  };

  // Trading Master Coming Soon Modal State
  const [showTradingMasterComingSoon, setShowTradingMasterComingSoon] = useState(false);
  const { toast } = useToast();

  // Share tradebook modal state
  const [showShareDialog, setShowShareDialog] = useState(false);
  const [shareableUrl, setShareableUrl] = useState<string | null>(null);
  const [isCreatingShareableLink, setIsCreatingShareableLink] = useState(false);
  const [isSharedReportMode, setIsSharedReportMode] = useState(false);
  const [sharedReportData, setSharedReportData] = useState<any>(null);

  // Handle shared report from URL query parameter
  useEffect(() => {
    const params = new URLSearchParams(window.location.search);
    const sharedReportId = params.get('sharedReport');

    if (sharedReportId) {
      // Open dialog immediately to show loading state
      setIsSharedReportMode(true);
      setShowShareDialog(true);

      // Fetch the shared report in background
      fetch(`/api/verified-reports/${sharedReportId}`)
        .then(res => res.json())
        .then(data => {
          if (data.success && data.report) {
            setSharedReportData(data.report);
            setShareableUrl(data.report.shareUrl);
          } else {
            // Close dialog if report not found
            setShowShareDialog(false);
            setIsSharedReportMode(false);
          }
        })
        .catch(err => {
          console.error('Failed to load shared report:', err);
          setShowShareDialog(false);
          setIsSharedReportMode(false);
        });
    }
  }, []);

  // Handle share dialog close in shared report mode
  const handleShareDialogClose = () => {
    setShowShareDialog(false);

    if (isSharedReportMode) {
      // Clean up query parameter and reset shared mode
      window.history.replaceState({}, '', '/');
      setIsSharedReportMode(false);
      setSharedReportData(null);
      setShareableUrl(null);
    }
  };

  // Centralized authentication check helper - ALL tab switches MUST use this
  const setTabWithAuthCheck = (tabName: string) => {
    const userId = localStorage.getItem('currentUserId');
    const userEmail = localStorage.getItem('currentUserEmail');

    // Robust check for Cloud Run compatibility
    if (!userId || !userEmail || userId === 'null' || userEmail === 'null') {
      console.log('[AUTH] Authentication required for tab:', tabName, '- redirecting to login');
      setLocation('/login');
      return false;
    }

    console.log('[AUTH] User authenticated, setting tab:', tabName);
    setActiveTab(tabName);
    return true;
  };

  // Check if user is logged in, redirect to login if not
  const checkAuthAndNavigate = (tabName: string) => {
    return setTabWithAuthCheck(tabName);
  };

  // Handle Trading Master access - only for chiranjeevi.perala99@gmail.com
  const handleTradingMasterAccess = () => {
    const userId = localStorage.getItem('currentUserId');
    const userEmail = localStorage.getItem('currentUserEmail');

    // Robust check for Cloud Run compatibility
    if (!userId || !userEmail || userId === 'null' || userEmail === 'null') {
      console.log('[AUTH] Authentication required for Trading Master - redirecting to login');
      setLocation('/login');
      return;
    }

    console.log('[AUTH] User authenticated for Trading Master check - email:', userEmail);
    // Check if user is authorized for Trading Master
    if (userEmail === 'chiranjeevi.perala99@gmail.com') {
      // Authorized user - navigate to trading-master tab
      setActiveTab('trading-master');
    } else {
      // Unauthorized user - show coming soon modal
      setShowTradingMasterComingSoon(true);
    }
  };

  // Create shareable trading report
  const handleCreateShareableLink = async () => {
    try {
      setIsCreatingShareableLink(true);

      // Gather trading data from the calendar
      const filteredData = getFilteredHeatmapData();
      const dates = Object.keys(filteredData).sort();

      // Calculate comprehensive stats
      let totalPnL = 0;
      let totalTrades = 0;
      let winningTrades = 0;
      let fomoCount = 0;
      const streaks: number[] = [];
      let currentStreak = 0;

      dates.forEach(dateKey => {
        const dayData = filteredData[dateKey];
        const metrics = dayData?.tradingData?.performanceMetrics || dayData?.performanceMetrics;
        const tags = dayData?.tradingData?.tradingTags || dayData?.tradingTags || [];

        if (metrics) {
          const netPnL = metrics.netPnL || 0;
          totalPnL += netPnL;
          totalTrades += metrics.totalTrades || 0;
          winningTrades += metrics.winningTrades || 0;

          // Track FOMO tags
          if (Array.isArray(tags) && tags.some((tag: string) => tag.toLowerCase() === 'fomo')) {
            fomoCount++;
          }

          // Track win streaks
          if (netPnL > 0) {
            currentStreak++;
          } else if (netPnL < 0 && currentStreak > 0) {
            streaks.push(currentStreak);
            currentStreak = 0;
          }
        }
      });

      // Final streak
      if (currentStreak > 0) {
        streaks.push(currentStreak);
      }

      const maxStreak = streaks.length > 0 ? Math.max(...streaks) : 0;
      const winRate = totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0;

      // Create verified report
      const response = await fetch('/api/verified-reports', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: currentUser?.userId || 'demo',
          username: currentUser?.displayName || currentUser?.email || 'Demo User',
          reportData: {
            tradingDataByDate: filteredData,
            totalPnL,
            totalTrades,
            winRate: Number(winRate.toFixed(2)),
            fomoCount,
            maxStreak,
            userId: currentUser?.userId || 'demo',
            username: currentUser?.displayName || currentUser?.email || 'Demo User',
            tagline: 'rethink & reinvest',
          }
        })
      });

      const result = await response.json();

      if (result.success && result.report) {
        setShareableUrl(result.report.shareUrl);
        toast({
          title: "Shareable link created!",
          description: "Your trading report is ready to share. Link expires in 7 days.",
        });
      } else {
        throw new Error(result.error || 'Failed to create shareable link');
      }
    } catch (error) {
      console.error('[SHARE] Error creating shareable link:', error);
      toast({
        title: "Error",
        description: "Failed to create shareable link. Please try again.",
        variant: "destructive",
      });
    } finally {
      setIsCreatingShareableLink(false);
    }
  };

  // AI Finance Assistant Logic - Real data fetching and analysis
  const fetchRealStockData = async (
    symbol: string,
  ): Promise<StockData | null> => {
    try {
      console.log(`🤖 AI Search fetching real data for ${symbol}...`);
      const response = await fetch(`/api/stock-analysis/${symbol}`);
      const data = await response.json();

      if (data && data.priceData) {
        console.log(
          `✅ AI Search got real data for ${symbol}:`,
          data.priceData,
        );
        return {
          symbol: symbol,
          price: data.priceData.close || data.priceData.price || 0,
          change: (data.priceData.close || 0) - (data.priceData.open || 0),
          changePercent: data.sentiment?.score
            ? ((data.priceData.close - data.priceData.open) /
                data.priceData.open) *
              100
            : 0,
          volume: data.priceData.volume || "N/A",
          marketCap: data.valuation?.marketCap || "N/A",
          pe: data.valuation?.peRatio || 0,
          high: data.priceData.high || 0,
          low: data.priceData.low || 0,
          open: data.priceData.open || 0,
          sentiment: data.sentiment || null,
          indicators: data.indicators || null,
        };
      }
      return null;
    } catch (error) {
      console.error(`❌ AI Search failed to fetch data for ${symbol}:`, error);
      return null;
    }
  };

  // Optimized unified search with caching and performance improvements
  const handleSearch = async (queryOverride?: string) => {
    let query = queryOverride || searchQuery;
    if (!query.trim()) return;

    // Convert stock symbol format (RELIANCE-EQ) to human language (reliance)
    if (query.includes('-') && query.toUpperCase() === query) {
      const symbolPart = query.split('-')[0]; // Extract "RELIANCE" from "RELIANCE-EQ"
      query = symbolPart.toLowerCase(); // Convert to "reliance"
      console.log(`✅ [SYMBOL-DETECTED] Converted ${queryOverride} to human language: ${query}`);
    }

    // Check authentication before allowing search
    const userId = localStorage.getItem('currentUserId');
    const userEmail = localStorage.getItem('currentUserEmail');

    if (!userId || !userEmail || userId === 'null' || userEmail === 'null') {
      console.log('[AUTH] Authentication required for search - redirecting to login');
      setLocation('/login');
      return;
    }

    // Prevent concurrent searches
    if (isSearchLoading) return;

    setIsSearchLoading(true);

    try {
      const message = query.toLowerCase();
      const stockSymbols = [
        "reliance",
        "tcs",
        "infy",
        "infosys",
        "hdfcbank",
        "icicibank",
        "bhartiartl",
        "itc",
        "nifty",
        "banknifty",
        "sbin",
        "adaniports",
        "asianpaint",
        "bajfinance",
        "wipro",
        "techm",
      ];
      const mentionedStock = stockSymbols.find((stock) =>
        message.includes(stock),
      );

      // USE TRADING AI AGENT FOR ALL QUERIES - Like Replit Agent for Trading
      // This agent uses tool calling to intelligently gather data from multiple sources
      console.log(
        "🤖 [TRADING-AGENT] Triggering AI Trading Agent (Tool Calling Enabled)...",
      );

      try {
        // Call the new Trading AI Agent endpoint
        const response = await fetch(getFullApiUrl("/api/trading-agent"), {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            query: query,
            context: {
              userId: currentUser?.userId || localStorage.getItem('currentUserId'),
            },
          }),
        });

        if (response.ok) {
          const data = await response.json();

          if (data.success && data.message) {
            let result = data.message;

            // Store chart data for rendering if available
            if (data.charts && data.charts.length > 0) {
              (window as any).tradingAgentCharts = data.charts;
              console.log("📊 [TRADING-AGENT] Received chart data:", data.charts.length, "charts");
            }

            // Store stock insights for rendering
            if (data.stocks && data.stocks.length > 0) {
              (window as any).tradingAgentStocks = data.stocks;
              console.log("📈 [TRADING-AGENT] Received stock insights:", data.stocks.length, "stocks");
            }

            // Store company insights data on window for chart rendering
            if (data.companyInsights) {
              (window as any).companyInsightsData = data.companyInsights;
              console.log("✅ [TRADING-AGENT] Received company insights:", data.companyInsights.symbol, data.companyInsights.trend);

              // Store stock data for chart display
              (window as any).aiAssistantStockData = {
                name: data.companyInsights.name || data.companyInsights.symbol,
                price: data.companyInsights.price || 0,
                change: (data.companyInsights.price || 0) - (data.companyInsights.open || 0),
                changePercent: ((data.companyInsights.price - (data.companyInsights.open || data.companyInsights.price)) / ((data.companyInsights.open || data.companyInsights.price) || 1)) * 100,
                symbol: data.companyInsights.symbol
              };
              (window as any).aiAssistantSelectedTimeframe = '1Y';

              // Fetch price chart data for the symbol
              try {
                const symbol = data.companyInsights.symbol || "";
                if (symbol) {
                  const chartResponse = await fetch(getFullApiUrl(`/api/stock-chart-data/${symbol}?timeframe=1Y`));
                  if (chartResponse.ok) {
                    const chartData = await chartResponse.json();
                    if (chartData && chartData.length > 0) {
                      (window as any).aiAssistantPriceChartData = chartData;
                      // Insert price chart marker at the beginning of results
                      result = "[CHART:PRICE_CHART]\n" + result;
                      console.log("📈 [TRADING-AGENT] Fetched price chart data:", chartData.length, "candles");
                    }
                  }
                }
              } catch (chartError) {
                console.warn("⚠️ Could not fetch price chart data:", chartError);
              }
            } else {
              (window as any).companyInsightsData = null;
            }

            // Add sources footer if available
            if (data.sources && data.sources.length > 0) {
              result += `\n\n---\n**Sources:** ${data.sources.join(' | ')}`;
            }

            setSearchResults(result);

            // Fetch news if query is about financial/market topics
            const isNewsQuery = query.toLowerCase().includes("news") || query.toLowerCase().includes("market") || query.toLowerCase().includes("update") || query.toLowerCase().includes("financial");
            if (isNewsQuery) {
              try {
                const newsPromises = ["IT", "FINANCE", "COMMODITY", "GLOBAL", "BANKS", "AUTOMOBILE"].map(sector =>
                  fetch("/api/daily-news", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ sector })
                  })
                    .then(res => res.json())
                    .then(data => ({...data, url: "#", source: sector, time: new Date().toLocaleTimeString()}))
                    .catch(err => null)
                );
                const results = await Promise.all(newsPromises);
                const validResults = results.filter(r => r !== null);
                if (validResults.length > 0) setSearchResultsNews(validResults);
              } catch (err) {console.warn("Error fetching news:", err);}
            }
            console.log("✅ [TRADING-AGENT] Query processing complete!");
            setIsSearchLoading(false);
            return;
          }
        }

        // Fallback to advanced-query if trading-agent fails
        console.log("⚠️ [TRADING-AGENT] Falling back to advanced query...");

        let journalTrades: any[] = [];
        try {
          const journalResponse = await fetch(getFullApiUrl("/api/journal/all-dates"));
          if (journalResponse.ok) {
            const allJournalData = await journalResponse.json();
            Object.entries(allJournalData).forEach(
              ([date, data]: [string, any]) => {
                if (data.tradeHistory && Array.isArray(data.tradeHistory)) {
                  journalTrades.push(
                    ...data.tradeHistory.map((trade: any) => ({
                      ...trade,
                      date,
                    })),
                  );
                }
              },
            );
          }
        } catch (journalError) {
          console.warn("⚠️ Could not load journal data:", journalError);
        }

        const fallbackResponse = await fetch(getFullApiUrl("/api/advanced-query"), {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query: query, journalTrades: journalTrades }),
        });

        if (fallbackResponse.ok) {
          const data = await fallbackResponse.json();
          if (data.companyInsights) {
            (window as any).companyInsightsData = data.companyInsights;
          }
          setSearchResults(data.answer);
          setIsSearchLoading(false);
          return;
        }
      } catch (error) {
        console.error("❌ [TRADING-AGENT] Error:", error);
        // Fall through to other handlers
      }

      // Technical Indicator Search (RSI, EMA, MACD, etc.)
      if (
        message.includes("rsi") ||
        message.includes("ema") ||
        message.includes("macd") ||
        message.includes("bollinger") ||
        message.includes("moving average") ||
        message.includes("technical")
      ) {
        const stock = (mentionedStock || "RELIANCE").toUpperCase();
        const realData = await fetchRealStockData(stock);

        if (realData) {
          const technicalResult = `## 📊 Technical Analysis: ${stock}

**🎯 Technical Indicators (Live Data):**
• **RSI (14):** ${realData.indicators?.rsi || "Calculating..."} ${
            parseFloat(realData.indicators?.rsi || "50") > 70
              ? "🔴 Overbought"
              : parseFloat(realData.indicators?.rsi || "50") < 30
                ? "🟢 Oversold"
                : "🟡 Neutral"
          }
• **EMA 50:** ₹${realData.indicators?.ema50 || "Loading..."}
• **MACD:** ${realData.indicators?.macd || "Processing..."}
• **Volume:** ${realData.volume} ${
            parseInt(String(realData.volume)) > 1000000
              ? "(High Volume)"
              : "(Normal Volume)"
          }

**📈 Price Action:**
• **Current:** ₹${realData.price.toLocaleString()} (${realData.changePercent.toFixed(
            2,
          )}%)
• **Support:** ₹${(realData.price * 0.98).toFixed(0)} | **Resistance:** ₹${(
            realData.price * 1.02
          ).toFixed(0)}
• **Trend:** ${
            realData.changePercent > 0 ? "Bullish momentum" : "Bearish pressure"
          }

**🔮 Trading Signals:**
${
  parseFloat(realData.indicators?.rsi || "50") > 70
    ? "• RSI suggests overbought condition - Consider profit booking"
    : parseFloat(realData.indicators?.rsi || "50") < 30
      ? "• RSI shows oversold levels - Potential buying opportunity"
      : "• RSI in neutral zone - Wait for clear signals"
}

**💡 Technical Strategy:**
Use Trading Master for detailed chart analysis with all 14 timeframes and advanced indicators.`;

          setSearchResults(technicalResult);
        } else {
          setSearchResults(
            `📊 **Technical Analysis Hub**\n\nAccess advanced technical indicators through:\n• **Trading Master:** Full charting suite with RSI, MACD, Bollinger Bands\n• **Live Options:** Greeks and technical levels\n• **Community Analysis:** Social Feed technical discussions\n\n🚀 Switch to Trading Master for comprehensive technical analysis.`,
          );
        }
      }

      // Social Feed Search - Optimized with timeout and caching
      else if (
        message.includes("social") ||
        message.includes("community") ||
        message.includes("discussion") ||
        message.includes("trending") ||
        message.includes("sentiment")
      ) {
        try {
          // Fast timeout for social data to prevent slow loading
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 2000); // 2 second timeout

          const socialResponse = await fetch(getFullApiUrl("/api/social-posts?limit=5"), {
            signal: controller.signal,
          });
          clearTimeout(timeoutId);

          if (socialResponse.ok) {
            const socialData = await socialResponse.json();

            // Filter relevant posts based on query
            let relevantPosts = socialData;
            if (mentionedStock) {
              relevantPosts = socialData.filter(
                (post: any) =>
                  post.content &&
                  post.content.toLowerCase().includes(mentionedStock),
              );
            }

            // Extract trending topics
            const trendingTopics = Array.from(
              new Set(
                socialData.flatMap((post: any) =>
                  (post.content?.match(/\b[A-Z]{3,}\b/g) || []).slice(0, 3),
                ),
              ),
            ).slice(0, 8);

            const socialResult = `## 💬 Social Feed Intelligence ${
              mentionedStock ? `- ${mentionedStock.toUpperCase()}` : ""
            }

**💹 Trending Discussions:**
${
  trendingTopics.map((topic) => `• ${topic}`).join("\n") ||
  "• General market discussions"
}

**📊 Community Insights (${relevantPosts.length} posts):**
${relevantPosts
  .slice(0, 5)
  .map(
    (post: any, index: number) =>
      `${index + 1}. **${post.authorUsername || "Trader"}:** ${(
        post.content || ""
      ).substring(0, 120)}...`,
  )
  .join("\n\n")}

**🎯 Sentiment Analysis:**
${
  relevantPosts.length > 0
    ? `Community is actively discussing ${
        mentionedStock ? mentionedStock.toUpperCase() + " with" : "market with"
      } ${
        relevantPosts.some(
          (p: any) =>
            p.content?.toLowerCase().includes("bullish") ||
            p.content?.toLowerCase().includes("buy"),
        )
          ? "bullish sentiment"
          : relevantPosts.some(
                (p: any) =>
                  p.content?.toLowerCase().includes("bearish") ||
                  p.content?.toLowerCase().includes("sell"),
              )
            ? "bearish sentiment"
            : "mixed sentiment"
      }`
    : "Limited recent discussions on this topic"
}

**🚀 Platform Integration:**
• **Full Feed:** Access complete Social Feed for detailed discussions  
• **Real-time Updates:** Live community posts and market reactions
• **Expert Analysis:** Professional trader insights and strategies

💡 **Quick Access:** Switch to Social Feed tab for complete community analysis.`;

            setSearchResults(socialResult);
          } else {
            setSearchResults(
              `💬 **Social Feed Center**\n\nAccess community insights:\n• **Live Discussions:** Real-time market conversations\n• **Expert Analysis:** Professional trader perspectives\n• **Trending Topics:** What the community is discussing\n\n🚀 Switch to Social Feed tab for full community analysis.`,
            );
          }
        } catch (error) {
          setSearchResults(
            `💬 **Social Feed Access**\n\nConnect with the trading community through our Social Feed tab for:\n• Live market discussions\n• Community sentiment analysis\n• Expert trading insights\n\n💡 Navigate to Social Feed for real-time community intelligence.`,
          );
        }
      }

      // Journal & Trading History Search
      else if (
        message.includes("journal") ||
        message.includes("trades") ||
        message.includes("history") ||
        message.includes("performance") ||
        message.includes("pnl")
      ) {
        const journalResult = `## 📝 Trading Journal & Performance Hub

**📊 Performance Analytics Available:**
• **Daily P&L Tracking:** Comprehensive trade-by-trade analysis
• **Strategy Performance:** Success rates and optimization insights  
• **Risk Management:** Drawdown analysis and position sizing
• **Pattern Recognition:** Identify winning and losing patterns

**💼 Journal Features:**
• **Trade Documentation:** Screenshots, notes, and market context
• **Tag System:** Categorize trades by strategy, emotion, setup
• **Performance Metrics:** Win rate, average profit/loss, Sharpe ratio
• **Calendar View:** Visual P&L heatmap and trading frequency

**🎯 Quick Journal Actions:**
• **Today's Trades:** Check current session performance
• **Weekly Review:** Analyze recent trading patterns  
• **Monthly Summary:** Comprehensive performance overview
• **Strategy Analysis:** Deep dive into specific trading approaches

**📈 Performance Insights:**
• **Best Performing Days:** Identify optimal trading conditions
• **Loss Analysis:** Understand and fix problematic patterns
• **Time Analysis:** Find your most profitable trading hours
• **Risk Metrics:** Monitor and optimize risk-adjusted returns

**🚀 Platform Integration:**
Use Journal tab for detailed performance tracking and trade analysis.`;

        setSearchResults(journalResult);
      }

      // Quick Actions (Add to watchlist, set alerts, etc.)
      else if (
        message.includes("add") ||
        message.includes("watchlist") ||
        message.includes("alert") ||
        message.includes("notification")
      ) {
        const quickResult = `## ⚡ Quick Actions Hub

**📋 Watchlist Management:**
${
  mentionedStock
    ? `• **Add ${mentionedStock.toUpperCase()}:** Monitor price movements and alerts
• **Set Price Alert:** Get notified at target levels
• **Technical Alert:** RSI/MACD signal notifications
• **News Alert:** Breaking news for ${mentionedStock.toUpperCase()}`
    : `• **Add Stocks:** Build your monitoring portfolio
• **Create Lists:** Sector-wise or strategy-based groupings
• **Bulk Actions:** Import/export watchlist data
• **Smart Alerts:** AI-powered signal notifications`
}

**🔔 Alert System:**
• **Price Targets:** Get notified at support/resistance levels
• **Technical Signals:** RSI overbought/oversold alerts
• **News Alerts:** Breaking developments on watched stocks
• **Volume Alerts:** Unusual trading activity notifications

**🎯 Quick Setup Actions:**
• **Portfolio Sync:** Connect with Trading Master for live tracking
• **Risk Alerts:** Position size and stop-loss monitoring  
• **Calendar Alerts:** Earnings, dividends, and event reminders
• **Community Alerts:** Social Feed mentions and discussions

**⚙️ Automation Features:**
• **Smart Scanning:** Auto-detect trading opportunities
• **Pattern Alerts:** Chart pattern recognition notifications
• **Sector Rotation:** Industry momentum change alerts
• **Market Regime:** Bull/bear market transition signals

**🚀 Platform Integration:**
Configure alerts through Trading Master and monitor via Social Feed updates.`;

        setSearchResults(quickResult);
      }

      // Stock price requests - Optimized with fast loading
      else if (
        message.includes("price") ||
        message.includes("stock") ||
        message.includes("nifty") ||
        message.includes("sensex") ||
        message.includes("live")
      ) {
        const stock = (mentionedStock || "RELIANCE").toUpperCase();

        // Show immediate response for better UX
        setSearchResults(
          `🔍 **Loading ${stock} Data...**\n\n⏱️ Fetching live market data...`,
        );

        // Use existing stock analysis endpoint with timeout
        let realData: StockData | null = null;
        try {
          realData = await Promise.race([
            fetchRealStockData(stock),
            new Promise<StockData | null>((_, reject) =>
              setTimeout(() => reject(new Error("Timeout")), 4000),
            ),
          ]);
        } catch (error) {
          console.log("Stock data timeout, using fallback");
        }

        if (realData) {
          // Get additional fundamental data from social feed
          let fundamentalData = "";
          try {
            const socialResponse = await fetch(getFullApiUrl("/api/social-posts?limit=5"));
            if (socialResponse.ok) {
              const socialData = await socialResponse.json();
              const relevantPosts = socialData.filter(
                (post: any) =>
                  post.content &&
                  (post.content.toLowerCase().includes(stock.toLowerCase()) ||
                    post.content.toLowerCase().includes("market") ||
                    post.content.toLowerCase().includes("analysis")),
              );

              if (relevantPosts.length > 0) {
                fundamentalData = `\n**📊 Community Analysis:**\n${relevantPosts
                  .slice(0, 2)
                  .map(
                    (post: any, index: number) =>
                      `${index + 1}. ${post.content.substring(0, 150)}...`,
                  )
                  .join("\n")}\n`;
              }
            }
          } catch (e) {
            console.log("Social data not available");
          }

          const trend = realData.changePercent > 0 ? "bullish" : "bearish";
          const trendIcon = trend === "bullish" ? "📈" : "📉";
          const sentimentEmoji =
            realData.sentiment?.trend === "Bullish"
              ? "🟢"
              : realData.sentiment?.trend === "Bearish"
                ? "🔴"
                : "🟡";
          const sentimentText = realData.sentiment?.trend || "Neutral";
          const sentimentConfidence =
            realData.sentiment?.confidence || "Medium";

          const analysisResult = `## ${stock} Stock Analysis ${trendIcon}

**📈 Live Market Data (Fyers API):**
• **Current Price:** ₹${realData.price.toLocaleString()} (${realData.changePercent.toFixed(
            2,
          )}%)
• **Open:** ₹${realData.open.toLocaleString()} | **High:** ₹${realData.high.toLocaleString()}
• **Low:** ₹${realData.low.toLocaleString()} | **Volume:** ${realData.volume}
• **Market Cap:** ${realData.marketCap}
• **P/E Ratio:** ${realData.pe || "N/A"}

**🎯 Market Sentiment:** ${sentimentEmoji} ${sentimentText} (${sentimentConfidence} confidence)

**📊 Technical Indicators:**
• **RSI:** ${realData.indicators?.rsi || "Calculating..."}
• **EMA 50:** ${realData.indicators?.ema50 || "Loading..."}
• **Trend:** ${trend === "bullish" ? "Upward momentum" : "Consolidation phase"}
• **Support:** ₹${(realData.price * 0.98).toFixed(0)} | **Resistance:** ₹${(
            realData.price * 1.02
          ).toFixed(0)}
${fundamentalData}
**💡 AI Trading Insight:**
${
  trend === "bullish"
    ? `Strong buying momentum with ${
        realData.volume
      } volume. Consider position entry with stop-loss below ₹${(
        realData.price * 0.95
      ).toFixed(0)}.`
    : `Cautious sentiment prevailing. Wait for confirmation above ₹${(
        realData.price * 1.02
      ).toFixed(0)} for bullish reversal.`
}

**⚖️ Risk Level:** ${
            realData.changePercent > 5
              ? "High"
              : realData.changePercent > 2
                ? "Medium"
                : "Low"
          } Volatility | ${sentimentConfidence} Confidence

🚀 **Platform Features:** Use Trading Master for advanced charts and options analysis.`;

          setSearchResults(analysisResult);
        } else {
          // Fallback with platform guidance
          setSearchResults(`📈 **${stock} Stock Analysis**

⏰ **Data Status:** Real-time data temporarily unavailable

**🔧 Alternative Data Sources:**
• **Trading Master:** Live charts, options chain, technical indicators
• **Social Feed:** Community analysis and discussions
• **Market Dashboard:** Real-time quotes and market sentiment

**📱 Platform Features Available:**
• **Live Options Chain:** Greeks calculation and analysis
• **Technical Charts:** 14 timeframes with indicators
• **Community Insights:** Social trading feed
• **Risk Management:** Journal and performance tracking

💡 **Quick Access:** Switch to Trading Master tab for live ${stock} data and analysis.`);
        }
      }

      // Market news requests using existing platform news data
      else if (
        message.includes("news") ||
        message.includes("market") ||
        message.includes("update")
      ) {
        try {
          // Use the same news API that's already working successfully
          const query = mentionedStock
            ? mentionedStock.toUpperCase()
            : "Indian stock market finance news";
          const response = await fetch(
            `/api/stock-news?query=${encodeURIComponent(query)}`,
          );
          const data = await response.json();

          if (data.success && data.articles && data.articles.length > 0) {
            // Organize the news data that's already being fetched
            const newsArticles = data.articles.slice(0, 6);

            // Analyze sentiment from the news
            const getNewssentiment = (articles: any[]) => {
              const positiveWords = [
                "growth",
                "profit",
                "gain",
                "rise",
                "bullish",
                "strong",
                "beat",
                "up",
                "higher",
                "surge",
              ];
              const negativeWords = [
                "loss",
                "decline",
                "fall",
                "bearish",
                "weak",
                "miss",
                "concern",
                "down",
                "lower",
                "crash",
              ];

              let positiveCount = 0;
              let negativeCount = 0;

              articles.forEach((article) => {
                const text = (
                  article.title +
                  " " +
                  (article.description || "")
                ).toLowerCase();
                positiveWords.forEach((word) => {
                  if (text.includes(word)) positiveCount++;
                });
                negativeWords.forEach((word) => {
                  if (text.includes(word)) negativeCount++;
                });
              });

              if (positiveCount > negativeCount)
                return {
                  sentiment: "Bullish",
                  score: positiveCount - negativeCount,
                };
              if (negativeCount > positiveCount)
                return {
                  sentiment: "Bearish",
                  score: negativeCount - positiveCount,
                };
              return { sentiment: "Neutral", score: 0 };
            };

            const sentimentAnalysis = getNewssentiment(newsArticles);
            const targetSymbol = mentionedStock
              ? mentionedStock.toUpperCase()
              : "Market";

            const newsResult = `## 📰 Latest ${targetSymbol} News & Analysis

**🎯 News Sentiment Analysis:**
• **Overall Tone:** ${sentimentAnalysis.sentiment} ${
              sentimentAnalysis.sentiment === "Bullish"
                ? "🟢"
                : sentimentAnalysis.sentiment === "Bearish"
                  ? "🔴"
                  : "🟡"
            }
• **Confidence Score:** ${Math.abs(sentimentAnalysis.score)} signals detected
• **Market Impact:** ${
              sentimentAnalysis.sentiment === "Bullish"
                ? "Positive momentum expected"
                : sentimentAnalysis.sentiment === "Bearish"
                  ? "Caution advised"
                  : "Mixed signals, focus on fundamentals"
            }

**📈 Trading Implications:**
${
  sentimentAnalysis.sentiment === "Bullish"
    ? `• Positive news flow may support price appreciation\n• Consider gradual position building on dips\n• Monitor for continuation patterns`
    : sentimentAnalysis.sentiment === "Bearish"
      ? `• Negative sentiment may create selling pressure\n• Wait for news clarity before fresh positions\n• Look for oversold bounce opportunities`
      : `• Mixed news requires balanced approach\n• Focus on technical levels over news sentiment\n• Maintain risk management discipline`
}

**📋 Recent Headlines (${newsArticles.length} articles):**
${newsArticles
  .map(
    (article: any, index: number) =>
      `${index + 1}. **${article.title}**\n   ${
        article.description || "Breaking market development"
      }\n   _Source: ${article.source || "Market News"}_`,
  )
  .join("\n\n")}

**💡 Platform Integration:**
• **Social Feed:** Community discussions about these developments
• **Trading Master:** Technical analysis with news correlation
• **Journal:** Track news-driven trading decisions

🚀 **Next Steps:** Use Social Feed for community insights on these news developments.`;

            setSearchResults(newsResult);
          } else {
            // Fallback when news API doesn't have data
            setSearchResults(`📰 **Market News Dashboard**

**🔧 News Sources Available:**
• **Social Feed:** Real-time community discussions and market insights
• **Trading Platform:** Live market updates and analysis
• **Community Posts:** User-generated market commentary

**📱 Platform Features:**
• **Breaking News:** Check Social Feed for latest developments
• **Market Analysis:** Community-driven insights and discussions
• **Technical Updates:** Trading Master for chart-based news correlation

**💡 Alternative Sources:**
• Switch to Social Feed tab for community market discussions
• Check Trading Master for technical news impact analysis
• Monitor Journal for news-driven trading patterns

🚀 **Quick Access:** Social Feed contains the most up-to-date market discussions.`);
          }
        } catch (error) {
          console.error("News fetch error:", error);
          setSearchResults(
            `📰 **News Center**\n\nAccess the latest market news through our platform features:\n\n• **Social Feed:** Community market discussions\n• **Trading Master:** Technical analysis and market updates\n• **Platform Dashboard:** Real-time market information\n\n💡 Use Social Feed for the most current market insights.`,
          );
        }
      }

      // IPO requests using AI Finance Assistant logic
      else if (
        message.includes("ipo") ||
        message.includes("listing") ||
        message.includes("upcoming")
      ) {
        const ipoAnalysis = `🚀 **IPO Market Intelligence**

**Current IPO Landscape:**
The IPO market is experiencing selective activity with quality companies commanding premium valuations. Key focus areas:

• **Technology Sector:** Fintech and SaaS companies leading the pipeline with strong digital transformation themes
• **Green Energy:** Renewable energy firms gaining significant investor attention amid sustainability focus
• **Healthcare:** Specialty pharma and medical device companies benefiting from health sector growth
• **Financial Services:** NBFCs and insurance companies exploring listings amid credit growth cycle

**Investment Framework for IPO Analysis:**

**1. Fundamental Due Diligence:**
• Business model sustainability and competitive moats
• Revenue growth consistency and profit margins
• Management track record and corporate governance
• Industry positioning and market opportunity size

**2. Valuation Assessment:**
• Compare with listed peers in same sector
• Evaluate growth prospects vs. premium pricing
• Assess price band reasonableness
• Consider post-listing price performance patterns

**3. Risk Evaluation:**
• Market timing and overall sentiment
• Lock-in period implications for promoters
• Regulatory environment and compliance history
• Competition intensity and market share sustainability

**Professional IPO Strategy:**
• **Research Phase:** Thorough analysis of DRHP and company financials
• **Application Strategy:** Multiple family member applications for better allocation
• **Post-Listing:** Monitor for 3-6 months before major position changes
• **Portfolio Integration:** Limit IPO exposure to 5-10% of total portfolio

**Current Market Dynamics:**
• Quality companies with clear business models preferred
• Premium valuations acceptable for proven growth stories
• Retail participation remains strong but selective
• Institutional investors focusing on long-term value creation

💡 **Platform Integration:** Use our Social Feed for community IPO discussions and Trading Master for technical analysis of newly listed stocks.`;

        setSearchResults(ipoAnalysis);
      }

      // Fundamental analysis using existing social feed data
      else if (
        message.includes("fundamental") ||
        message.includes("analysis") ||
        message.includes("financials")
      ) {
        try {
          // Combine stock data with social feed fundamental insights
          const stock = mentionedStock
            ? mentionedStock.toUpperCase()
            : "MARKET";

          // Get stock data and social feed data in parallel
          const [stockData, socialResponse] = await Promise.all([
            mentionedStock ? fetchRealStockData(stock) : Promise.resolve(null),
            fetch("/api/social-posts?limit=10"),
          ]);

          let fundamentalInsights = "";
          if (socialResponse.ok) {
            const socialData = await socialResponse.json();
            // Filter for fundamental analysis posts
            const fundamentalPosts = socialData.filter(
              (post: any) =>
                post.content &&
                (post.content.toLowerCase().includes("pe ratio") ||
                  post.content.toLowerCase().includes("p/e") ||
                  post.content.toLowerCase().includes("valuation") ||
                  post.content.toLowerCase().includes("earnings") ||
                  post.content.toLowerCase().includes("fundamental") ||
                  post.content.toLowerCase().includes("financial") ||
                  post.content.toLowerCase().includes("balance sheet") ||
                  post.content.toLowerCase().includes("revenue") ||
                  post.content.toLowerCase().includes("profit margin") ||
                  (mentionedStock &&
                    post.content
                      .toLowerCase()
                      .includes(mentionedStock.toLowerCase()))),
            );

            if (fundamentalPosts.length > 0) {
              fundamentalInsights = `**📈 Community Fundamental Analysis:**
${fundamentalPosts
  .slice(0, 3)
  .map(
    (post: any, index: number) =>
      `${index + 1}. ${post.content.substring(0, 200)}...`,
  )
  .join("\n\n")}

`;
            }
          }

          if (stockData && mentionedStock) {
            // Specific stock fundamental analysis
            const fundamentalResult = `## ${stock} Fundamental Analysis 📊

**📋 Key Financial Metrics (Live Data):**
• **Current Price:** ₹${stockData.price.toLocaleString()}
• **Market Capitalization:** ${stockData.marketCap}
• **P/E Ratio:** ${stockData.pe || "N/A"} ${
              stockData.pe
                ? stockData.pe < 15
                  ? "(Attractive)"
                  : stockData.pe < 25
                    ? "(Fair)"
                    : "(Premium)"
                : ""
            }
• **Daily Volume:** ${stockData.volume}
• **Price Change:** ${stockData.changePercent.toFixed(2)}% (${
              stockData.changePercent > 0
                ? "Positive momentum"
                : "Under pressure"
            })

**💹 Valuation Assessment:**
${
  stockData.pe > 0
    ? `• P/E of ${stockData.pe} suggests ${
        stockData.pe < 15
          ? "**undervalued** opportunity"
          : stockData.pe < 25
            ? "**fairly valued** with reasonable premium"
            : "**premium valuation** requiring strong growth"
      }\n• Sector comparison needed for complete picture`
    : "• P/E data unavailable - focus on revenue and earnings trends\n• Check recent quarterly results for growth trajectory"
}

**🎯 Investment Framework:**
• **Growth Quality:** Consistent revenue and earnings expansion
• **Financial Health:** Strong balance sheet with manageable debt levels
• **Market Position:** Competitive advantages and market share trends
• **Management:** Track record of value creation and strategic vision

**⚠️ Risk Analysis:**
• **Volatility Level:** ${
              stockData.changePercent > 5
                ? "High"
                : stockData.changePercent > 2
                  ? "Medium"
                  : "Low"
            } (based on recent price movement)
• **Sentiment Risk:** ${
              stockData.sentiment?.confidence || "Medium"
            } confidence level
• **Liquidity:** ${
              stockData.volume !== "N/A"
                ? "Good trading volumes"
                : "Limited liquidity"
            }

${fundamentalInsights}**💡 Platform Resources:**
• **Trading Master:** Complete financial ratios and technical analysis
• **Social Feed:** Community fundamental discussions and insights
• **Market Dashboard:** Real-time valuation metrics

🚀 **Next Steps:** Check Social Feed for community fundamental analysis discussions.`;

            setSearchResults(fundamentalResult);
          } else {
            // General fundamental analysis framework with social insights
            const generalFundamental = `📊 **Fundamental Analysis Center**

**🔍 Platform Data Sources:**
• **Social Feed:** Community fundamental analysis and insights
• **Trading Master:** Complete financial ratios and valuation metrics
• **Market Data:** Real-time price and volume information

${fundamentalInsights}**📈 Essential Analysis Framework:**

**1. Profitability Ratios:**
• **ROE (Return on Equity):** >15% indicates efficient capital use
• **ROA (Return on Assets):** >10% shows strong asset management
• **Net Margin:** >10% suggests healthy profitability
• **EBITDA Margin:** Industry-specific operational efficiency

**2. Valuation Metrics:**
• **P/E Ratio:** Compare with sector average and growth rate
• **P/B Ratio:** <3 generally attractive for most sectors
• **EV/EBITDA:** Comprehensive valuation including debt structure
• **PEG Ratio:** <1 indicates growth at reasonable price

**3. Financial Strength:**
• **Debt-to-Equity:** <0.5 preferred for financial stability
• **Current Ratio:** >1.5 shows good short-term liquidity
• **Interest Coverage:** >5x indicates comfortable debt servicing
• **Free Cash Flow:** Positive and growing cash generation

**🎯 Sector-Wise Opportunities:**

**Banking (P/E: 12-15x)**
• Post-cycle recovery phase with improving asset quality
• Focus: Private banks with strong digital transformation

**Technology (P/E: 20-25x)**
• Premium justified by consistent growth and global exposure
• Focus: Export-oriented companies with recurring revenue models

**FMCG (P/E: 35-45x)**
• Quality premium for stable cash flows and market leadership
• Focus: Rural recovery themes and premiumization trends

**🚨 Red Flags to Avoid:**
⚠️ Declining revenue for 3+ consecutive quarters
⚠️ Rising debt without corresponding asset growth
⚠️ Frequent management changes or governance issues
⚠️ Sector headwinds without clear resolution path

**💡 Platform Integration:**
• **Social Feed:** Real-time community fundamental discussions
• **Trading Master:** Detailed financial ratio analysis
• **Journal:** Track fundamental-based investment decisions

🚀 **Quick Access:** Social Feed contains active fundamental analysis discussions.`;

            setSearchResults(generalFundamental);
          }
        } catch (error) {
          console.error("Fundamental analysis error:", error);
          setSearchResults(
            `📊 **Fundamental Analysis Hub**\n\n**📱 Available Resources:**\n• **Social Feed:** Community fundamental discussions\n• **Trading Master:** Financial ratios and analysis tools\n• **Platform Data:** Real-time market and company information\n\n💡 Check Social Feed for active fundamental analysis discussions.`,
          );
        }
      }

      // Advanced AI Search - Uses Gemini AI + Web Search (like Replit Agent)
      else {
        console.log(`🤖 Using Advanced AI Agent for query: ${query}`);

        try {
          const response = await fetch(getFullApiUrl("/api/advanced-search"), {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              query,
              includeWebSearch: true,
            }),
          });

          const data = await response.json();

          if (data.success && data.answer) {
            let result = `## 🤖 AI Assistant\n\n${data.answer}`;

            if (data.sources && data.sources.length > 0) {
              result += `\n\n**📚 Sources:**\n${data.sources.map((source: string) => `• ${source}`).join("\n")}`;
            }

            setSearchResults(result);
          } else {
            throw new Error("AI search failed");
          }
        } catch (error) {
          console.error("Advanced AI search error:", error);

          const fallbackResponse = `🤖 **AI Trading Assistant Ready!**\n\nI can help you with comprehensive trading and investment analysis:\n\n📈 **Live Stock Prices & Analysis:**\n• Real-time market data and technical indicators\n• Sector performance and trend analysis\n• Support/resistance levels and price targets\n\n📰 **Market News & Updates:**\n• Latest financial news and market movements\n• Economic indicators and policy impacts\n• Corporate earnings and sector trends\n\n🚀 **IPO Analysis & Information:**\n• Upcoming IPO calendar and subscription details\n• Post-listing performance tracking\n• Investment recommendations and risk assessment\n\n📊 **Fundamental Analysis:**\n• Company financials and valuation metrics\n• Sector comparisons and growth prospects\n• Risk analysis and investment recommendations\n\n💡 **Try asking:** "Get NIFTY price", "Latest market news", "IPO updates", or "Analyze fundamentals"`;

          setSearchResults(fallbackResponse);
        }
      }
    } catch (error) {
      console.error("AI Search error:", error);
      setSearchResults(
        "🤖 I'm here to help with all your trading and finance questions! I can assist with:\n\n• Stock analysis and live quotes\n• Market news and IPO updates\n• Trading strategies and risk management\n• Platform features (Trading Master, Journal, Social Feed)\n• Options trading and Greeks calculation\n\nWhat would you like to know more about?",
      );
    } finally {
      setIsSearchLoading(false);
    }
  };

  // Handle suggestion button clicks
  const handleSuggestionClick = (suggestion: string) => {
    setSearchQuery(suggestion);
    setIsSearchActive(true);
    // Automatically trigger search with the suggestion
    handleSearch(suggestion);
  };

  // Generate Trading Journal AI Performance Report
  const generateJournalAIReport = async () => {
    setIsSearchLoading(true);
    setIsSearchActive(true);
    setSearchQuery("Trading Journal Performance Analysis");

    try {
      // Fetch all journal dates and data
      const allDatesResponse = await fetch(getFullApiUrl("/api/journal/all-dates"));
      const allJournalData = allDatesResponse.ok
        ? await allDatesResponse.json()
        : {};

      // AWS is the only data source - no localStorage fallback
      const journalData = allJournalData;

      if (Object.keys(journalData).length === 0) {
        setSearchResults(
          "## 📝 Trading Journal Analysis\n\n❌ **No journal data found**\n\nPlease add some trading entries in the Journal tab to see your performance analysis.",
        );
        setIsSearchLoading(false);
        return;
      }

      // Analyze journal data for performance metrics
      let totalTrades = 0;
      let winningTrades = 0;
      let losingTrades = 0;
      let totalProfit = 0;
      let totalLoss = 0;
      let netPnL = 0;
      let fomoTrades = 0;
      let psychologyTags: { [key: string]: number } = {};
      let dailyPnL: { date: string; pnl: number }[] = [];

      // Process each date's journal data
      Object.entries(journalData).forEach(([date, dateData]: [string, any]) => {
        if (dateData && typeof dateData === "object") {
          // Extract trades from the date data - use correct structure
          const trades = dateData.tradeHistory || dateData.trades || [];
          const notes = dateData.tradingNotes || dateData.notes || "";
          const tags = dateData.tradingTags || dateData.selectedTags || [];

          let dayPnL = 0;

          trades.forEach((trade: any) => {
            totalTrades++;

            // Parse P&L from string format like "₹506.80", "₹-826.00"
            let pnl = 0;
            if (trade.pnl && typeof trade.pnl === "string") {
              const pnlStr = trade.pnl.replace(/[₹,+\s]/g, ""); // Remove ₹, commas, + and spaces
              pnl = parseFloat(pnlStr) || 0;
            } else if (typeof trade.pnl === "number") {
              pnl = trade.pnl;
            }

            dayPnL += pnl;

            if (pnl > 0) {
              winningTrades++;
              totalProfit += pnl;
            } else if (pnl < 0) {
              losingTrades++;
              totalLoss += Math.abs(pnl);
            }
          });

          // Count psychology tags
          tags.forEach((tag: string) => {
            psychologyTags[tag] = (psychologyTags[tag] || 0) + 1;
            if (tag.toLowerCase().includes("fomo")) {
              fomoTrades++;
            }
          });

          // Track daily P&L for trend analysis
          if (dayPnL !== 0) {
            dailyPnL.push({ date, pnl: dayPnL });
          }

          netPnL += dayPnL;
        }
      });

      const winRate =
        totalTrades > 0 ? Math.round((winningTrades / totalTrades) * 100) : 0;
      const avgWin =
        winningTrades > 0 ? Math.round(totalProfit / winningTrades) : 0;
      const avgLoss =
        losingTrades > 0 ? Math.round(totalLoss / losingTrades) : 0;

      // Get top psychology patterns
      const topPsychologyPatterns = Object.entries(psychologyTags)
        .sort(([, a], [, b]) => b - a)
        .slice(0, 3)
        .map(([tag, count]) => `${tag} (${count}x)`)
        .join(", ");

      // Generate mini performance trend (last 10 trading days)
      const recentTrend = dailyPnL.slice(-10);
      const trendData = recentTrend.map((day) => day.pnl).join(",");

      // Create performance trend visualization (simple ASCII-style)
      const maxPnL = Math.max(...recentTrend.map((d) => d.pnl));
      const minPnL = Math.min(...recentTrend.map((d) => d.pnl));
      const range = maxPnL - minPnL;

      let trendLine = "";
      if (range > 0) {
        recentTrend.forEach((day) => {
          const normalized = Math.round(((day.pnl - minPnL) / range) * 10);
          trendLine += normalized >= 5 ? "📈" : normalized >= 3 ? "📊" : "📉";
        });
      }

      // Create chart data for Performance Trend
      const chartData = recentTrend.map((day, index) => ({
        day: `Day ${index + 1}`,
        value: day.pnl,
        date: day.date,
      }));

      const performanceReport = `## 📝 Trading Journal AI Performance Report

### 📊 **Overall Performance Metrics**
**🎯 Total Trades:** ${totalTrades}
**✅ Winning Trades:** ${winningTrades} (${winRate}% Win Rate)
**❌ Losing Trades:** ${losingTrades}
**💰 Net P&L:** ₹${netPnL.toLocaleString("en-IN")} ${netPnL >= 0 ? "🟢" : "🔴"}

### 💡 **Detailed Analytics**
**📈 Total Profit:** ₹${totalProfit.toLocaleString("en-IN")}
**📉 Total Loss:** ₹${totalLoss.toLocaleString("en-IN")}
**⚡ Average Win:** ₹${avgWin.toLocaleString("en-IN")}
**⚠️ Average Loss:** ₹${avgLoss.toLocaleString("en-IN")}

### 🧠 **Psychology Analysis**
**💹 FOMO Trades:** ${fomoTrades} trades
**🎭 Top Patterns:** ${topPsychologyPatterns || "No patterns identified"}

### 📈 **Performance Trend (Recent)**
[CHART:PERFORMANCE_TREND]
*${recentTrend.length} trading sessions tracked*

### 🎯 **AI Insights & Recommendations**
${
  winRate >= 60
    ? "🟢 **Strong Performance:** Your win rate shows good trading discipline!"
    : winRate >= 40
      ? "🟡 **Moderate Performance:** Focus on improving entry/exit timing."
      : "🔴 **Needs Improvement:** Consider reviewing your trading strategy and risk management."
}

${
  fomoTrades > totalTrades * 0.2
    ? "⚠️ **FOMO Alert:** High emotional trading detected. Consider implementing cooling-off periods."
    : "✅ **Good Discipline:** Low FOMO trading indicates strong emotional control."
}

**📚 Next Steps:**
• Review losing trades for common patterns
• Maintain detailed trade notes for better analysis
• ${
        netPnL < 0
          ? "Focus on risk management and position sizing"
          : "Continue current strategy with slight optimizations"
      }

---
*📱 Use Journal tab for detailed trade entries and analysis*`;

      // Store chart data for rendering
      (window as any).performanceTrendChartData = chartData;

      setSearchResults(performanceReport);
    } catch (error) {
      console.error("Error generating journal report:", error);
      setSearchResults(
        "## 📝 Trading Journal Analysis\n\n❌ **Error loading journal data**\n\nPlease try again or check your internet connection.",
      );
    } finally {
      setIsSearchLoading(false);
    }
  };

  // Function to fetch trending podcasts for a specific sector
  const fetchTrendingPodcasts = async (sector: string) => {
    setIsPodcastsLoading(true);
    try {
      const response = await fetch(getFullApiUrl("/api/trending-podcasts"), {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ sector }),
      });

      if (response.ok) {
        const data = await response.json();
        setTrendingPodcasts(data.podcasts || []);
      } else {
        throw new Error("Failed to fetch trending podcasts");
      }
    } catch (error) {
      console.error("Error fetching trending podcasts:", error);
      setTrendingPodcasts([]);
    } finally {
      setIsPodcastsLoading(false);
    }
  };

  // Handler for sector change
  const handleSectorChange = (sector: string) => {
    setSelectedSector(sector);
    fetchTrendingPodcasts(sector);
    setSelectedPodcast(null); // Clear selected podcast when sector changes
  };

  // Dynamic greeting based on local time
  const getTimeBasedGreeting = () => {
    const hour = new Date().getHours();
    if (hour >= 5 && hour < 12) {
      return "Hey, Good Morning! 🌅";
    } else if (hour >= 12 && hour < 17) {
      return "Hey, Good Afternoon! ☀️";
    } else if (hour >= 17 && hour < 21) {
      return "Hey, Good Evening! 🌆";
    } else {
      return "Hey, Good Night! 🌙";
    }
  };

  // Handler for podcast selection
  const handlePodcastSelect = (podcast: any) => {
    setSelectedPodcast(podcast);
  };

  // Load default podcasts on startup
  React.useEffect(() => {
    fetchTrendingPodcasts("FINANCE");
  }, []);

  // Podcasts are now only selected when manually clicked
  // Removed AI image generation - using user provided images

  // State to track slope pattern configuration from TradingMaster
  const [slopePatternConfig, setSlopePatternConfig] = useState({
    symbol: "NSE:INFY-EQ",
    timeframe: "1",
    fromDate: format(new Date(), "yyyy-MM-dd"),
    toDate: format(new Date(), "yyyy-MM-dd"),
  });

  // Event images - using gradient placeholders for cloud deployment
  const getEventImage = (eventName: string) => {
    // Return a data URL with gradient based on event type
    const gradients: Record<string, string> = {
      "Global Startup Summit | Hyderabad 2025": "linear-gradient(135deg, #667eea 0%, #764ba2 100%)",
      "TiE Bangalore Founders Summit": "linear-gradient(135deg, #f093fb 0%, #f5576c 100%)",
      "Pharma Bio Summit Hyderabad": "linear-gradient(135deg, #667eea 0%, #764ba2 100%)",
      "Hyderabad Food Festival": "linear-gradient(135deg, #fa709a 0%, #fee140 100%)",
      "HITEX IT Expo Hyderabad": "linear-gradient(135deg, #f093fb 0%, #f5576c 100%)",
      "Mumbai Fintech Festival": "linear-gradient(135deg, #30cfd0 0%, #330867 100%)",
      "Nasscom Product Conclave Bangalore": "linear-gradient(135deg, #f093fb 0%, #f5576c 100%)",
      "India AI Summit Mumbai": "linear-gradient(135deg, #f093fb 0%, #f5576c 100%)",
    };
    const gradient = gradients[eventName] || "linear-gradient(135deg, #667eea 0%, #764ba2 100%)";
    // Return empty string to use CSS gradient instead
    return "";
  };

  // Removed AI image generation effects

  // Import Modal State
  const [showImportModal, setShowImportModal] = useState(false);
  const [showConnectDialog, setShowConnectDialog] = useState(false);

  const [zerodhaAccessToken, setZerodhaAccessToken] = useState<string | null>(null);
  const [zerodhaIsConnected, setZerodhaIsConnected] = useState(false);
  const [zerodhaClientId, setZerodhaClientId] = useState<string | null>(null);
  const [brokerFunds, setBrokerFunds] = useState<number | null>(() => {
    if (typeof window !== "undefined") {
      const saved = localStorage.getItem("zerodha_broker_funds");
      return saved ? parseFloat(saved) : null;
    }
    return null;
  });
  const [zerodhaUserName, setZerodhaUserName] = useState<string | null>(null);
const [zerodhaTradesDialog, setZerodhaTradesDialog] = useState(false);
  const [showUserId, setShowUserId] = useState(true);
  const [zerodhaTradesLoading, setZerodhaTradesLoading] = useState(false);
  const [zerodhaTradesData, setZerodhaTradesData] = useState<any[]>([]);
  const [zerodhaProfileData, setZerodhaProfileData] = useState<any>(null);
  const [importData, setImportData] = useState("");
  const [importError, setImportError] = useState("");
  const [upstoxIsConnected, setUpstoxIsConnected] = useState(false);
  const [upstoxAccessToken, setUpstoxAccessToken] = useState<string | null>(null);
  const [upstoxUserId, setUpstoxUserId] = useState<string | null>(null);
  const [upstoxUserName, setUpstoxUserName] = useState<string | null>(null);

  useEffect(() => {
    if (upstoxAccessToken) {
      fetch("/api/upstox/profile")
        .then(r => r.json())
        .then(data => {
          if (data.success) {
            const userId = data.userId && data.userId !== "undefined" ? data.userId : null;
            const userName = data.userName && data.userName !== "undefined" ? data.userName : null;
            
            if (userId) {
              setUpstoxUserId(userId);
              localStorage.setItem("upstox_user_id", userId);
            }
            if (userName) {
              setUpstoxUserName(userName);
              localStorage.setItem("upstox_user_name", userName);
            }
          }
        })
        .catch(err => console.error("Failed to fetch Upstox profile:", err));
    }
  }, [upstoxAccessToken]);
  const [angelOneAccessToken, setAngelOneAccessToken] = useState<string | null>(null);
  const [angelOneIsConnected, setAngelOneIsConnected] = useState(false);
  const [dhanAccessToken, setDhanAccessToken] = useState<string | null>(null);
  const [dhanIsConnected, setDhanIsConnected] = useState(false);
  // Zerodha OAuth Handlers
  // Check localStorage on mount to restore connection state
  useEffect(() => {
    console.log('🔷 [ZERODHA] Checking localStorage on mount...');
    const savedToken = localStorage.getItem('zerodha_token');
    console.log('🔷 [ZERODHA] Saved token:', savedToken ? 'FOUND ✅' : 'NOT FOUND ❌');
    if (savedToken) {
      setZerodhaAccessToken(savedToken);
      setZerodhaIsConnected(true);
      console.log('✅ [ZERODHA] Connection restored from localStorage');
      const savedClientId = localStorage.getItem('zerodha_client_id');
      if (savedClientId) {
        setZerodhaClientId(savedClientId);
        console.log('✅ [ZERODHA] Client ID restored from localStorage');
      }
    } else {
      console.log('⚠️ [ZERODHA] No saved token in localStorage');
    }
      const savedUserName = localStorage.getItem("zerodha_user_name");
      if (savedUserName && savedUserName !== "undefined") {
        setZerodhaUserName(savedUserName);
        console.log("✅ [ZERODHA] User Name restored from localStorage");
      }
  }, []);


  // Fetch Zerodha profile to get both userId and userName - with persistence

  // Restore Upstox connection from localStorage on mount
  useEffect(() => {
    console.log('🔵 [UPSTOX] Checking localStorage on mount...');
    const savedToken = localStorage.getItem('upstox_token');
    console.log('🔵 [UPSTOX] Saved token:', savedToken ? 'FOUND ✅' : 'NOT FOUND ❌');
    if (savedToken) {
      setUpstoxAccessToken(savedToken);
      setUpstoxIsConnected(true);
      console.log('✅ [UPSTOX] Connection restored from localStorage');
      const savedUserId = localStorage.getItem('upstox_user_id');
      const savedUserName = localStorage.getItem('upstox_user_name');
      if (savedUserId) {
        setUpstoxUserId(savedUserId);
        console.log('✅ [UPSTOX] User ID restored from localStorage');
      }
      if (savedUserName && savedUserName !== "undefined") {
        setUpstoxUserName(savedUserName);
        console.log('✅ [UPSTOX] User Name restored from localStorage');
      }
    } else {
      console.log('⚠️ [UPSTOX] No saved token in localStorage');
    }
  }, []);

  // Restore Angel One connection from localStorage on mount
  useEffect(() => {
    console.log('✅ [ANGEL ONE] Checking localStorage on mount...');
    const savedToken = localStorage.getItem('angel_one_token');
    console.log('✅ [ANGEL ONE] Saved token:', savedToken ? 'FOUND ✅' : 'NOT FOUND ❌');
    if (savedToken) {
      setAngelOneAccessToken(savedToken);
      setAngelOneIsConnected(true);
      console.log('✅ [ANGEL ONE] Connection restored from localStorage');
    } else {
      console.log('⚠️ [ANGEL ONE] No saved token in localStorage');
    }
  }, []);

  // Restore Dhan connection from localStorage on mount
  useEffect(() => {
    console.log('🔵 [DHAN] Checking localStorage on mount...');
    const savedToken = localStorage.getItem('dhan_token');
    console.log('🔵 [DHAN] Saved token:', savedToken ? 'FOUND ✅' : 'NOT FOUND ❌');
    if (savedToken) {
      setDhanAccessToken(savedToken);
      setDhanIsConnected(true);
      console.log('✅ [DHAN] Connection restored from localStorage');
    } else {
      console.log('⚠️ [DHAN] No saved token in localStorage');
    }
  }, []);

  useEffect(() => {
    if (zerodhaAccessToken) {
      // Check if we already have profile in localStorage
      const savedId = localStorage.getItem('zerodha_client_id');
      const savedName = localStorage.getItem('zerodha_user_name');
      
      if (savedId && savedName && !zerodhaClientId) {
        setZerodhaClientId(savedId);
        setZerodhaUserName(savedName);
        console.log('✅ [ZERODHA] Profile restored from cache');
        return;
      }
      
      // If not in cache or state, fetch it from backend
      if (!zerodhaClientId || !zerodhaUserName) {
        const fetchZerodhaProfile = async () => {
          try {
            const response = await fetch('/api/broker/zerodha/profile', {
              headers: {
                'Authorization': `Bearer ${zerodhaAccessToken}`
              }
            });
            if (response.ok) {
              const data = await response.json();
              if (data.profile && data.profile.userId && data.profile.userName) {
                localStorage.setItem('zerodha_client_id', data.profile.userId);
                localStorage.setItem('zerodha_user_name', data.profile.userName);
                setZerodhaClientId(data.profile.userId);
                setZerodhaUserName(data.profile.userName);
                setZerodhaProfileData(data.profile);
                console.log('✅ [ZERODHA] Profile fetched and saved:', data.profile.userId);
              }
            }
          } catch (error) {
            console.error('❌ [ZERODHA] Failed to fetch profile:', error);
          }
        };
        fetchZerodhaProfile();
      }
    }
  }, [zerodhaAccessToken]);

  // Handle Zerodha OAuth callback from URL (popup communication)
  useEffect(() => {
    const handleZerodhaCallback = async () => {
      console.log('🔷 [ZERODHA] Checking URL for callback token...');
      const params = new URLSearchParams(window.location.search);
      const zerodhaToken = params.get("zerodha_token");
      console.log('🔷 [ZERODHA] Token in URL:', zerodhaToken ? '✅ FOUND' : '❌ NOT FOUND');
      
      if (zerodhaToken) {
        console.log('✅ [ZERODHA] Token received in URL:', zerodhaToken.substring(0, 20) + '...');
        localStorage.setItem("zerodha_token", zerodhaToken); document.cookie = `zerodha_token=${zerodhaToken}; path=/; SameSite=Lax; Secure`; setZerodhaAccessToken(zerodhaToken); setZerodhaIsConnected(true);
        setZerodhaAccessToken(zerodhaToken);
        setZerodhaIsConnected(true);
        
        // Notify parent window if this is a popup
        if (window.opener) {
          console.log("📡 Sending token to opener:", window.opener.location.origin); window.opener.postMessage({ type: "ZERODHA_TOKEN", token: zerodhaToken }, "*");
          console.log('📡 Sent token to parent window');
        }
        
        // Fetch trades
        setTimeout(() => {
          setZerodhaTradesLoading(true);
          fetch("/api/broker/zerodha/trades", {
            headers: { "Authorization": `Bearer ${zerodhaToken}` }
          })
            .then(res => res.json())
            .then(data => {
              setZerodhaTradesData(data.trades || []);
              setZerodhaTradesDialog(true);
              console.log('✅ Zerodha trades fetched:', data.trades?.length);
              
              // Close popup after trades loaded
              if (window.opener) {
                setTimeout(() => window.close(), 2000);
              }
            })
            .catch(err => console.error("Error fetching Zerodha trades:", err))
            .finally(() => setZerodhaTradesLoading(false));
        }, 300);
        
        window.history.replaceState({}, document.title, window.location.pathname);
      }
    };
    
    handleZerodhaCallback();
  }, []);

  // Listen for messages from popup windows
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      console.log("📡 [MESSAGE] Received message:", event.data.type, event.data);
      
      if (event.data.type === 'ANGELONE_AUTH_SUCCESS' && event.data.token) {
        const token = event.data.token;
        console.log('✅ [ANGELONE] Token received from popup:', token.substring(0, 20) + '...');
        
        localStorage.setItem("angelone_token", token);
        if (event.data.feedToken) localStorage.setItem("angelone_feed_token", event.data.feedToken);
        if (event.data.refreshToken) localStorage.setItem("angelone_refresh_token", event.data.refreshToken);
        if (event.data.clientCode) localStorage.setItem("angelone_client_code", event.data.clientCode);
        
        document.cookie = `angelone_token=${token}; path=/; SameSite=Lax; Secure`;
        setAngelOneAccessToken(token);
        setAngelOneIsConnected(true);
        setShowConnectDialog(false);
        
        console.log('✅ [ANGELONE] Connection established and saved to localStorage');
      } else if (event.data.type === 'ZERODHA_TOKEN' && event.data.token) {
        const token = event.data.token;
        console.log('✅ [ZERODHA] Token received from popup:', token.substring(0, 20) + '...');
        
        localStorage.setItem("zerodha_token", token); document.cookie = `zerodha_token=${token}; path=/; SameSite=Lax; Secure`; setZerodhaAccessToken(token); setZerodhaIsConnected(true);
        setZerodhaAccessToken(token);
        setZerodhaIsConnected(true);
        setShowConnectDialog(false);
        console.log('✅ [ZERODHA] Connection established and saved to localStorage');
        
        // Fetch trades
        setTimeout(() => {
          // Also fetch profile
          fetch("/api/broker/zerodha/profile", {
            headers: { "Authorization": `Bearer ${token}` }
          })
            .then(res => res.json())
            .then(data => {
              if (data.profile) {
                setZerodhaProfileData(data.profile);
                setZerodhaClientId(data.profile.userId);
                setZerodhaUserName(data.profile.userName);
                localStorage.setItem("zerodha_client_id", data.profile.userId);
                localStorage.setItem("zerodha_user_name", data.profile.userName);
                console.log('✅ [ZERODHA] Profile fetched:', data.profile.email);
              }
            })
            .catch(err => console.error("❌ [ZERODHA] Error fetching profile:", err));

          console.log('📡 [ZERODHA] Fetching trades with token...');
          setZerodhaTradesLoading(true);
          fetch("/api/broker/zerodha/trades", {
            headers: { "Authorization": `Bearer ${token}` }
          })
            .then(res => res.json())
            .then(data => {
              setZerodhaTradesData(data.trades || []);
              setZerodhaTradesDialog(true);
              console.log('✅ [ZERODHA] Trades fetched:', data.trades?.length || 0, 'trades');
            })
            .catch(err => {
              console.error("❌ [ZERODHA] Error fetching trades:", err);
            })
            .finally(() => setZerodhaTradesLoading(false));
        }, 300);
      } else if (event.data.type === 'ZERODHA_ERROR') {
        console.error('❌ [ZERODHA] Error from callback:', event.data.error);
        alert('Zerodha error: ' + event.data.error);
      } else if (event.data.type === 'DHAN_TOKEN' && event.data.token) {
        const token = event.data.token;
        console.log('🔵 [DHAN] Token received from popup:', token.substring(0, 20) + '...');
        
        localStorage.setItem("dhan_token", token);
        localStorage.setItem("dhan_token", token);
        localStorage.setItem("dhan_user_id", "dhan_user");
        localStorage.setItem("dhan_user_name", "Dhan Account");
        document.cookie = `dhan_token=${token}; path=/; SameSite=Lax; Secure`;
        setDhanIsConnected(true);
        setShowConnectDialog(false);
        console.log('✅ [DHAN] Connection established and saved to localStorage');
      } else if (event.data.type === 'ANGEL_ONE_TOKEN' && event.data.token) {
        const token = event.data.token;
        console.log('🔶 [ANGEL ONE] Token received from popup:', token.substring(0, 20) + '...');
        
        localStorage.setItem("angel_one_token", token);
        document.cookie = `angel_one_token=${token}; path=/; SameSite=Lax; Secure`;
        setAngelOneAccessToken(token);
        setAngelOneIsConnected(true);
        setShowConnectDialog(false);
        console.log('✅ [ANGEL ONE] Connection established and saved to localStorage');
      } else if (event.data.type === 'ANGEL_ONE_ERROR') {
        console.error('❌ [ANGEL ONE] Error from callback:', event.data.error);
        alert('Angel One error: ' + event.data.error);
      } else if (event.data.type === 'DHAN_ERROR') {
        console.error('❌ [DHAN] Error from callback:', event.data.error);
        alert('Dhan error: ' + event.data.error);
      }
    };
    
    window.addEventListener('message', handleMessage);
    return () => window.removeEventListener('message', handleMessage);
  }, []);

  const handleZerodhaConnect = async () => {
    try {
      console.log('🔷 Starting Zerodha OAuth flow...');
      const response = await fetch('/api/broker/zerodha/login-url');
      const data = await response.json();
      
      if (data.error) {
        alert('Setup Error:\n' + data.message + '\n\nSteps to fix:\n1. Go to https://developers.kite.trade\n2. Click your app\n3. Find "Redirect URL" and register:\nhttps://YOUR_APP_DOMAIN/api/broker/zerodha/callback\n4. Save and try again');
        return;
      }
      
      const { loginUrl } = data;
      console.log('🔗 Zerodha login URL:', loginUrl);
      
      const popup = window.open(
        loginUrl,
        'zerodha_oauth',
        'width=600,height=800,resizable=yes,scrollbars=yes'
      );
      
      if (!popup) {
        console.warn('❌ Popup blocked, falling back to main window');
        alert('Popup blocked. Please enable popups and try again.');
        return;
      }
      
      console.log('✅ Popup opened, waiting for OAuth callback...');
      
      // Monitor popup closing
      let checkCount = 0;
      const monitorPopup = setInterval(() => {
        checkCount++;
        if (popup.closed) {
          clearInterval(monitorPopup);
          console.log('⚠️ Zerodha popup closed');
          return;
        }
        if (checkCount > 300) {
          clearInterval(monitorPopup);
          popup.close();
          console.log('⚠️ Zerodha popup timeout');
        }
      }, 1000);
      
    } catch (error) {
      console.error('❌ Zerodha error:', error);
      alert('Error: ' + (error instanceof Error ? error.message : 'Failed to connect'));
    }
  };

  const handleUpstoxConnect = async () => {
    try {
      console.log('🔵 Starting Upstox OAuth flow...');
      const response = await fetch('/api/upstox/auth-url');
      const data = await response.json();
      
      if (!data.authUrl) {
        alert('Error: Could not generate Upstox authorization URL');
        return;
      }
      
      console.log('🔗 Upstox auth URL:', data.authUrl);
      
      const popup = window.open(
        data.authUrl,
        'upstox_oauth',
        'width=600,height=800,resizable=yes,scrollbars=yes'
      );
      
      if (!popup) {
        console.warn('❌ Popup blocked, falling back to main window');
        alert('Popup blocked. Please enable popups and try again.');
        return;
      }
      
      console.log('✅ Upstox popup opened, waiting for OAuth callback...');
      
      // Listen for messages from the OAuth callback popup
      const messageListener = (event: MessageEvent) => {
        if (event.data.type === "UPSTOX_AUTH_SUCCESS") {
          console.log("✅ Upstox authentication successful!");
          localStorage.setItem("upstox_token", event.data.token);
          localStorage.setItem("upstox_user_id", event.data.userId || "");
          localStorage.setItem("upstox_user_email", event.data.userEmail || "");
          localStorage.setItem("upstox_user_name", event.data.userName || "");
          setUpstoxAccessToken(event.data.token);
          setUpstoxIsConnected(true);
          window.removeEventListener("message", messageListener);
          toast({
            title: "Success",
            description: "Upstox connected successfully!",
          });
        } else if (event.data.type === "UPSTOX_AUTH_ERROR") {
          console.error("❌ Upstox authentication failed:", event.data.error);
          window.removeEventListener("message", messageListener);
          toast({
            title: "Error",
            description: event.data.error || "Failed to authenticate with Upstox",
            variant: "destructive",
          });
        }
      };

      window.addEventListener("message", messageListener);
      
      // Monitor popup closing and cleanup
      let checkCount = 0;
      const monitorPopup = setInterval(() => {
        checkCount++;
        if (popup.closed) {
          clearInterval(monitorPopup);
          window.removeEventListener("message", messageListener);
          console.log('⚠️ Upstox popup closed');
          return;
        }
        if (checkCount > 300) {
          clearInterval(monitorPopup);
          window.removeEventListener("message", messageListener);
          popup.close();
          console.log('⚠️ Upstox popup timeout');
        }
      }, 1000);
      
    } catch (error) {
      console.error('❌ Upstox error:', error);
      alert('Error: ' + (error instanceof Error ? error.message : 'Failed to connect to Upstox'));
    }
  };

  const handleUpstoxDisconnect = async () => {
    try {
      const token = upstoxAccessToken;
      if (!token) {
        // No token to revoke, just clear locally
        localStorage.removeItem("upstox_token");
        localStorage.removeItem("upstox_user_id");
        localStorage.removeItem("upstox_user_email");
        localStorage.removeItem("upstox_user_name");
        setUpstoxAccessToken(null);
        setUpstoxIsConnected(false);
        return;
      }

      // Call Upstox logout API
      const response = await fetch('https://api.upstox.com/v2/logout', {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'Authorization': `Bearer ${token}`
        }
      });

      console.log('🔵 Upstox logout response:', response.status);
      
      // Clear local storage regardless of API response
      localStorage.removeItem("upstox_token");
      localStorage.removeItem("upstox_user_id");
      localStorage.removeItem("upstox_user_email");
      localStorage.removeItem("upstox_user_name");
      setUpstoxAccessToken(null);
      setUpstoxIsConnected(false);
    } catch (error) {
      console.error('❌ Upstox disconnect error:', error);
      // Clear local storage even if API call fails
      localStorage.removeItem("upstox_token");
      localStorage.removeItem("upstox_user_id");
      localStorage.removeItem("upstox_user_email");
      localStorage.removeItem("upstox_user_name");
      setUpstoxAccessToken(null);
      setUpstoxIsConnected(false);
    }
  };

  const handleAngelOneConnect = async () => {
    try {
      console.log("🔶 Attempting Angel One auto-login (web scraping)...");
      
      // Try auto-login first (uses backend credentials + TOTP)
      const autoLoginResponse = await fetch("/api/angelone/auto-login", {
        method: "POST",
        headers: { "Content-Type": "application/json" }
      });
      
      const autoLoginData = await autoLoginResponse.json();
      
      if (autoLoginData.success && autoLoginData.token && autoLoginData.feedToken) {
        console.log("✅ [ANGEL ONE] Auto-login successful! Using backend credentials...");
        localStorage.setItem("angel_one_token", autoLoginData.token);
        localStorage.setItem("angel_one_refresh_token", autoLoginData.refreshToken || "");
        localStorage.setItem("angel_one_feed_token", autoLoginData.feedToken);
        localStorage.setItem("angel_one_client_code", autoLoginData.clientCode);
        setAngelOneAccessToken(autoLoginData.token);
        setAngelOneIsConnected(true);
        toast({ title: "Success", description: `Connected to Angel One (${autoLoginData.clientCode})` });
        return;
      }
      
      console.log("⚠️ Auto-login failed, checking status endpoint...");
      const response = await fetch("/api/angelone/status");
      const data = await response.json();
      
      if (data.isConnected && data.token && data.feedToken) {
        console.log("✅ [ANGEL ONE] Using status endpoint tokens!");
        localStorage.setItem("angel_one_token", data.token);
        localStorage.setItem("angel_one_refresh_token", data.refreshToken || "");
        localStorage.setItem("angel_one_feed_token", data.feedToken);
        localStorage.setItem("angel_one_client_code", data.clientCode || "P176266");
        setAngelOneAccessToken(data.token);
        setAngelOneIsConnected(true);
        toast({ title: "Success", description: `Connected to Angel One (${data.clientCode || "P176266"})` });
        return;
      }
      
      console.log("⚠️ No tokens available, attempting popup OAuth...");
      const authResponse = await fetch("/api/angelone/auth-url");
      const authData = await authResponse.json();
      
      if (!authData.authUrl) {
        toast({ variant: "destructive", title: "Error", description: "Could not generate authorization URL" });
        return;
      }
      
      console.log("🔗 Angel One auth URL generated");
      
      const popup = window.open(
        authData.authUrl,
        "angel_one_oauth",
        "width=600,height=800,resizable=yes,scrollbars=yes"
      );
      
      if (!popup) {
        toast({ variant: "destructive", title: "Error", description: "Popup blocked. Please enable popups and try again." });
        return;
      }
      
      console.log("✅ Angel One popup opened, waiting for authentication...");
      
      const messageListener = (event: MessageEvent) => {
        if (event.data.type === "ANGELONE_AUTH_SUCCESS") {
          console.log("✅ [ANGEL ONE] Successfully authenticated via popup!");
          localStorage.setItem("angel_one_token", event.data.token);
          localStorage.setItem("angel_one_refresh_token", event.data.refreshToken);
          localStorage.setItem("angel_one_feed_token", event.data.feedToken);
          localStorage.setItem("angel_one_client_code", event.data.clientCode);
          setAngelOneAccessToken(event.data.token);
          setAngelOneIsConnected(true);
          window.removeEventListener("message", messageListener);
          clearInterval(monitorPopupRef);
          toast({ title: "Success", description: `Connected to Angel One (${event.data.clientCode})` });
        } else if (event.data.type === "ANGELONE_AUTH_ERROR") {
          console.error("❌ Angel One error:", event.data.error);
          window.removeEventListener("message", messageListener);
          clearInterval(monitorPopupRef);
          toast({ variant: "destructive", title: "Error", description: event.data.error || "Authentication failed" });
        }
      };
      
      window.addEventListener("message", messageListener);
      
      let checkCount = 0;
      const monitorPopupRef = setInterval(() => {
        checkCount++;
        if (popup.closed) {
          clearInterval(monitorPopupRef);
          window.removeEventListener("message", messageListener);
          console.log("⚠️ Angel One popup closed");
          return;
        }
        if (checkCount > 300) {
          clearInterval(monitorPopupRef);
          window.removeEventListener("message", messageListener);
          popup.close();
          toast({ variant: "destructive", title: "Error", description: "Authentication timeout" });
        }
      }, 100);
      
    } catch (error) {
      console.error("❌ Angel One error:", error);
      toast({ variant: "destructive", title: "Error", description: error instanceof Error ? error.message : "Failed to connect" });
    }
  };

  const handleAngelOneConnect_OLD = async () => {
    try {
      console.log('🔶 Starting Angel One OAuth flow...');
      const response = await fetch('/api/angel-one/auth-url');
      const data = await response.json();
      
      if (!data.authUrl) {
        alert('Error: Could not generate Angel One authorization URL');
        return;
      }
      
      console.log('🔗 Angel One auth URL:', data.authUrl);
      
      const popup = window.open(
        data.authUrl,
        'angel_one_oauth',
        'width=600,height=800,resizable=yes,scrollbars=yes'
      );
      
      if (!popup) {
        console.warn('❌ Popup blocked');
        alert('Popup blocked. Please enable popups and try again.');
        return;
      }
      
      console.log('✅ Angel One popup opened, polling for authentication...');
      
      let checkCount = 0;
      const pollAuthStatus = setInterval(async () => {
        checkCount++;
        
        if (popup.closed) {
          clearInterval(pollAuthStatus);
          console.log('⚠️ Angel One popup closed by user');
          return;
        }
        
        try {
          const statusResponse = await fetch('/api/angel-one/status');
          const status = await statusResponse.json();
          
          if (status.authenticated && status.accessToken) {
            console.log('✅ [ANGEL ONE] Authenticated! Token received:', status.accessToken.substring(0, 20) + '...');
            clearInterval(pollAuthStatus);
            
            // STORE TOKEN AND UPDATE STATE
            localStorage.setItem('angel_one_token', status.accessToken);
            localStorage.setItem('angel_one_client_code', status.clientCode || 'P176266');
            document.cookie = `angel_one_token=${status.accessToken}; path=/; max-age=86400`;
            
            setAngelOneAccessToken(status.accessToken);
            setAngelOneIsConnected(true);
            
            console.log('💾 Stored Angel One token in localStorage and cookies');
            
            popup.close();
            setConnectDialogOpen(false);
            return;
          }
        } catch (err) {
          console.debug('🔶 [ANGEL ONE] Status polling...');
        }
        
        if (checkCount > 300) {
          clearInterval(pollAuthStatus);
          popup.close();
          console.log('⚠️ Angel One timeout');
          alert('Angel One login timeout. Please try again.');
        }
      }, 1000);
      
    } catch (error) {
      console.error('❌ Angel One error:', error);
      alert('Error: ' + (error instanceof Error ? error.message : 'Failed to connect'));
    }
  };

  const handleDhanConnect = async () => {
    try {
      console.log('🔵 Starting Dhan OAuth flow...');
      const response = await fetch('/api/broker/dhan/login-url');
      const data = await response.json();
      
      if (data.error) {
        alert('Setup Error:\n' + data.error);
        return;
      }
      
      const { loginUrl } = data;
      console.log('🔗 Dhan login URL:', loginUrl);
      
      const popup = window.open(
        loginUrl,
        'dhan_oauth',
        'width=600,height=800,resizable=yes,scrollbars=yes'
      );
      
      if (!popup) {
        console.warn('❌ Popup blocked');
        alert('Popup blocked. Please enable popups and try again.');
        return;
      }
      
      console.log('✅ Popup opened, waiting for OAuth callback...');
      
      let checkCount = 0;
      const monitorPopup = setInterval(() => {
        checkCount++;
        if (popup.closed) {
          clearInterval(monitorPopup);
          console.log('⚠️ Dhan popup closed');
          return;
        }
        if (checkCount > 300) {
          clearInterval(monitorPopup);
          popup.close();
          console.log('⚠️ Dhan popup timeout');
        }
      }, 1000);
      
    } catch (error) {
      console.error('❌ Dhan error:', error);
      alert('Error: ' + (error instanceof Error ? error.message : 'Failed to connect'));
    }
  };

  const handleRevokeZerodha = () => {
    localStorage.removeItem("zerodha_token"); document.cookie = "zerodha_token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/";
    setZerodhaAccessToken(null);
    setZerodhaIsConnected(false);
    setZerodhaTradesData([]);
    console.log('🔓 Zerodha connection revoked');
  };

  const handleFetchZerodhaTrades = async () => {
    if (!zerodhaAccessToken) {
      alert('Please connect to Zerodha first');
      return;
    }
    
    setZerodhaTradesLoading(true);
    try {
      const response = await fetch('/api/broker/zerodha/trades', {
        headers: { 'Authorization': `Bearer ${zerodhaAccessToken}` }
      });
      const { trades } = await response.json();
      setZerodhaTradesData(trades);
      setZerodhaTradesDialog(true);
    } catch (error) {
      console.error('Error fetching trades:', error);
      alert('Failed to fetch trades');
    } finally {
      setZerodhaTradesLoading(false);
    }
  };
  const [parseErrors, setParseErrors] = useState<ParseError[]>([]);
  const [isBuildMode, setIsBuildMode] = useState(false);

  // Define the format type with position-based structure (supports multiple positions per field)
  type FormatData = {
    id?: string;  // Unique ID for the format (generated on save)
    label?: string;  // Human-readable label for display
    sampleLine: string;  // Original first line of trade data
    positions: {
      time: number[];  // Array of positions
      order: number[];
      symbol: number[];
      type: number[];
      qty: number[];
      price: number[];
    };
    // Keep string values for display in build table
    displayValues: {
      time: string;
      order: string;
      symbol: string;
      type: string;
      qty: string;
      price: string;
    };
  };

  // Define ParseResult type for trade parsing
  type ParseResult = {
    trades: any[];
    errors: ParseError[];
  };

  const [buildModeData, setBuildModeData] = useState<FormatData>({
    sampleLine: "",
    positions: {
      time: [],
      order: [],
      symbol: [],
      type: [],
      qty: [],
      price: []
    },
    displayValues: {
      time: "",
      order: "",
      symbol: "",
      type: "",
      qty: "",
      price: ""
    }
  });
  const [brokerSearchInput, setBrokerSearchInput] = useState("");
  const [showBrokerSuggestions, setShowBrokerSuggestions] = useState(false);
  const [availableBrokers, setAvailableBrokers] = useState<string[]>([
    // Top Discount Brokers
    "Zerodha", "Groww", "Angel One", "Upstox", "5paisa", "Fyers", "Paytm Money", "Alice Blue",
    "Shoonya by Finvasia", "Samco Securities", "Motilal Oswal",

    // Crypto Exchanges & Brokers
    "Coinbase", "Kraken", "Binance", "Delta Exchange", "WazirX", "Bybit", "OKX", "Huobi",
    "Kucoin", "FTX", "Gemini", "Bitstamp", "Upbit", "Bithumb", "Crypto.com", "Bitcoin India",
    "CoinDCX", "Zebpay", "BTCXIndia", "Unocoin", "BTCXINDIA", "Paxful", "LocalBitcoins", "Coinswitch",

    // Full-Service Brokers
    "ICICI Securities", "HDFC Securities", "Kotak Securities", "Axis Securities",
    "SBI Securities", "Sharekhan", "IIFL Securities", "JM Financial",
    "Geojit Financial", "Edelweiss Broking", "Religare Broking", "Centrum Broking",

    // Bank-Integrated Brokers
    "YES Bank Securities", "IDBI Bank Securities", "RBL Bank", "Aditya Birla Money",
    "Federal Bank Securities", "Bandhan Bank Securities",

    // Other Established Brokers
    "Arihant Capital", "Ashika Stock Broking", "Augment Financial", "B. D. Ranka",
    "Bhavik Shares & Stock Brokers", "Bombay Bullion", "Bosch Stock Broking",
    "BrightMoney", "Brokerking", "CARE Broking", "Choice Equities", "Cityline Stock Brokers",
    "Claire Equity", "Clearly Brokerage", "D. A. Stock Broking", "Deepak Stock Brokers",
    "Dhanraj Brokers", "Dharwani Equities", "DHI Finance", "Dolat Brokerage",
    "Edelweiss Private", "ERM Stock Brokers", "Equity Infotech", "Euro Exim Securities",
    "Exclusive Equities", "Federal Bank Broking", "Fimpro Financial", "Fincare Stock Broking",
    "Finquest Securities", "Finvasia", "Fiscal Broking", "Flat Securities",
    "Flipstone Consultancy", "Fortis Broking", "Forward Broking", "Fortwell Equities",
    "Four Stone Consultants", "Frances Commodities", "Franklin Securities", "Gajjar Securities",
    "Ganesh Securities", "Garuda Capstock", "Gaurav Stock Brokers", "GCL Securities",
    "Genesis Broking", "Geo Securities", "Ginodia Stock Brokers", "Global Capital",
    "Global Equities", "Global Funds", "Global Securities", "Globe Brokers",
    "Glorious Capital", "Good Sign Equities", "Grand Finserve", "Grapes Broking",
    "Gravesham Broking", "Grin Broking", "GT Securities", "Guide Stock Brokers",
    "Gulimex Broking", "Gumption Securities", "Gupta Securities", "Guru Arjun Consultants",
    "Gurukul Equities", "Gyan Capital", "Gyan Securities", "H. R. Equities",
    "Harsh Broking", "Harveys Broking", "Hasib Securities", "Haycroft Broking",
    "Helix Securities", "H Equities", "Heritage Broking", "Heston Brokers",
    "Hi-Tech Securities", "Hi-Wealth Stock Brokers", "Himalayan Equities", "Himalaya Capital",
    "Hind Securities", "Hindsight Broking", "Hippo Broking", "Hoho Equities",
    "Holistic Investments", "Holmes Broking", "Home Capital", "Homestead Equities",
    "Honing Brokers", "Horizon Equities", "Horizon Securities", "Horizo Broking",
    "Horseplay Broking", "Hot Stock Brokers", "House of Brokers", "Houston Capital",
    "Hovercraft Brokers", "Howdy Equities", "Hullark Brokers", "Hullabaloo Capital",
    "Humana Securities", "Humble Brokers", "Humidor Equities", "Humility Securities",
    "Humor Capital", "Hump Day Brokers", "Huntec Capital", "Huntsman Equities",
    "Hurdles Broking", "Hurray Securities", "Hurricane Capital", "Hurried Brokers",
    "Hurtling Equities", "Husband Broking", "Hush Capital", "Hustle Brokers",
    "Hustlers Equities", "Hut Stock Brokers", "Hydrogen Capital", "Hyped Equities",
    "Hype Broking", "Hypothesis Capital", "Hyundai Securities", "Hyve Broking",

    // Indian Stock Brokers (Additional)
    "Invested", "Indiabulls Securities", "IIFL Wealth", "IndiaMart Securities",
    "Jagjeet Stock Brokers", "Jaiprakash Securities", "Jal Stock Broking", "Jalamar Brokers",
    "Jalata Equities", "Jamboree Capital", "Jambul Brokers", "Jamestown Securities",
    "Jan Capital", "Janata Broking", "Janglee Equities", "Janitor Securities",
    "Jannat Capital", "Janta Brokers", "Jaswant Broking", "Jata Securities",
    "Jayant Brokers", "Jayesh Equities", "Jayesh Securities", "Jb Capital",
    "Jdm Securities", "Jeera Broking", "Jeeva Equities", "Jehandad Capital",
    "Jen Stock Broking", "Jenco Securities", "Jericho Brokers", "Jerkin Equities",
    "Jeroboam Capital", "Jerry's Broking", "Jet Brokers", "Jetpack Securities",
    "Jetta Capital", "Jetton Equities", "Jewell Securities", "Jfc Capital",
    "Jha Stock Brokers", "Jhon Broking", "Jhoti Securities", "Jhunjhunwala Brokers",
    "Jig Securities", "Jigsaw Brokers", "Jihad Capital", "Jila Equities",
    "Jill's Broking", "Jilt Securities", "Jimbo Brokers", "Jimnastic Capital",
    "Jimmy's Equities", "Jin Capital", "Jingle Broking", "Jingle Bells Securities",
    "Jingle Jangle Brokers", "Jingly Equities", "Jingoism Capital", "Jinxed Securities",
    "Jirawala Brokers", "Jism Equities", "Jitney Capital", "Jitter Broking",
    "Jittery Securities", "Jiuzhaigou Brokers", "Jive Capital", "Jive Equities",
    "Jive Turkey Brokers", "Jiver Securities", "Jjim Capital", "Job Broking",
    "Jobber Equities", "Jobcentre Capital", "Jobless Securities", "Jobname Brokers",
    "Jobsworth Equities", "Jock Capital", "Jockey Broking", "Jockeys Securities",
    "Jocular Brokers", "Jocund Equities", "Jodeci Capital", "Jodhpur Securities",
    "Jodhpurs Broking", "Jodi Brokers", "Joe Capital", "Joes Equities",
    "Joey's Broking", "Joeys Securities", "Jog Capital", "Jogee Brokers",
    "Jogging Equities", "Joggs Securities", "Joghurt Capital", "Jogles Broking",
    "John Deere Brokers", "John Equities", "Johns Capital", "Johnny Broking",
    "Johnny's Securities", "Johnnys Brokers", "Johny's Capital", "Join Equities",
    "Joined Securities", "Joining Capital", "Joins Broking", "Joint Equities",
    "Joint Venture Securities", "Jointed Brokers", "Jointless Capital", "Joists Equities",
    "Joist Securities", "Joke Capital", "Joker Broking", "Jokers Equities",
    "Jokes Securities", "Jokester Capital", "Jokily Broking", "Jokiness Equities"
  ]);
  const [savedFormats, setSavedFormats] = useState<Record<string, FormatData>>({});
  const [activeFormat, setActiveFormat] = useState<FormatData | null>(null);
  const [detectedFormatLabel, setDetectedFormatLabel] = useState<string | null>(null);
  const [formatsLoading, setFormatsLoading] = useState(false);
  const importDataTextareaRef = useRef<HTMLTextAreaElement>(null);

  const filteredBrokers = brokerSearchInput.trim() 
    ? availableBrokers.filter(b => b.toLowerCase().includes(brokerSearchInput.toLowerCase()))
    : [];

  // Check if all columns are filled
  const allColumnsFilledForSave = 
    buildModeData.positions.time.length > 0 &&
    buildModeData.positions.order.length > 0 &&
    buildModeData.positions.symbol.length > 0 &&
    buildModeData.positions.type.length > 0 &&
    buildModeData.positions.qty.length > 0 &&
    buildModeData.positions.price.length > 0;

  // Get missing columns for tooltip
  const missingColumns = [];
  if (buildModeData.positions.time.length === 0) missingColumns.push("Time");
  if (buildModeData.positions.order.length === 0) missingColumns.push("Order");
  if (buildModeData.positions.symbol.length === 0) missingColumns.push("Symbol");
  if (buildModeData.positions.type.length === 0) missingColumns.push("Type");
  if (buildModeData.positions.qty.length === 0) missingColumns.push("Qty");
  if (buildModeData.positions.price.length === 0) missingColumns.push("Price");

  // Helper function to save formats to Universal Broker Library AND user personal formats
  const saveFormatToUniversalLibrary = async (formatLabel: string, format: FormatData, brokerName: string) => {
    if (!currentUser?.userId) {
      toast({
        title: "Authentication Required",
        description: "Please log in to save formats",
        variant: "destructive"
      });
      return false;
    }

    try {
      const idToken = await getCognitoToken();
      if (!idToken) return false;

      // Generate a unique ID for this format (timestamp + random suffix)
      const uniqueFormatId = `${brokerName}_${formatLabel}_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;

      // Create format with ID and label embedded
      const formatWithMetadata: FormatData = {
        ...format,
        id: uniqueFormatId,
        label: formatLabel
      };

      console.log(`💾 Saving format "${formatLabel}" to ${brokerName} library with ID: ${uniqueFormatId}`);
      const response = await fetch('/api/broker-formats/save', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${idToken}`
        },
        body: JSON.stringify({
          brokerName,
          formatName: formatLabel,
          sampleLine: format.sampleLine,
          positions: format.positions,
          displayValues: format.displayValues,
          userId: currentUser.userId
        })
      });

      const data = await response.json();
      if (response.ok) {
        console.log(`✅ Format saved to ${brokerName} library`);

        // SYNC to user's personal formats for live preview
        // Use unique ID as key to prevent overwriting existing formats with same label
        const updatedFormats = {
          ...savedFormats,
          [uniqueFormatId]: formatWithMetadata
        };
        setSavedFormats(updatedFormats);

        // Also set this as the active format immediately
        setActiveFormat(formatWithMetadata);
        setDetectedFormatLabel(formatLabel);

        // Save to user's personal formats backend
        const userFormatsResponse = await fetch(`/api/user-formats/${currentUser.userId}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${idToken}`
          },
          body: JSON.stringify(updatedFormats)
        });

        if (userFormatsResponse.ok) {
          console.log(`✅ Format also synced to personal formats for live preview`);
        }

        toast({
          title: "Format Saved Successfully",
          description: `Your format "${formatLabel}" has been saved to the ${brokerName} library!`
        });
        return true;
      } else {
        console.error("❌ Failed to save format:", data.error);
        toast({
          title: "Save Failed",
          description: data.error || "Failed to save format to library",
          variant: "destructive"
        });
        return false;
      }
    } catch (error) {
      console.error("❌ Error saving format:", error);
      toast({
        title: "Network Error",
        description: "Could not connect to server",
        variant: "destructive"
      });
      return false;
    }
  };


  // Load user's saved formats from AWS when user is authenticated
  useEffect(() => {
    const loadUserFormats = async () => {
      console.log("🔄 loadUserFormats triggered, currentUser:", currentUser?.userId ? `userId: ${currentUser.userId}` : "NO USER");

      if (!currentUser?.userId) {
        console.log("⏳ No authenticated user, skipping format load");
        setSavedFormats({});
        setFormatsLoading(false);
        return;
      }

      setFormatsLoading(true);
      try {
        console.log("📥 Loading user formats for userId:", currentUser.userId);
        const idToken = await getCognitoToken();
        if (!idToken) {
          console.error("❌ Failed to get Cognito ID token");
          setFormatsLoading(false);
          return;
        }

        console.log("🔑 Got Cognito ID token, making request to /api/user-formats/", currentUser.userId);
        const response = await fetch(`/api/user-formats/${currentUser.userId}`, {
          headers: {
            'Authorization': `Bearer ${idToken}`
          }
        });

        console.log("📡 Response status:", response.status, response.statusText);
        if (response.ok) {
          const formats = await response.json();
          console.log("✅ Loaded formats from AWS:", Object.keys(formats).length, "formats", formats);
          setSavedFormats(formats);
          if (Object.keys(formats).length > 0) {
            console.log("📦 Formats available in dropdown:", Object.keys(formats).join(", "));
          }
        } else {
          const errorText = await response.text();
          console.log("📭 No saved formats found in AWS, status:", response.status, "error:", errorText);
          setSavedFormats({});
        }
      } catch (error) {
        console.error("❌ Error loading user formats:", error);
        setSavedFormats({});
      } finally {
        setFormatsLoading(false);
      }
    };

    loadUserFormats();
  }, [currentUser?.userId]);

  // Reload formats when import dialog opens
  useEffect(() => {
    if (showImportModal && currentUser?.userId) {
      console.log("📂 Import dialog opened, reloading formats...");
      setFormatsLoading(true);
      // Create a function to reload formats without dependency on state
      (async () => {
        try {
          const idToken = await getCognitoToken();
          if (idToken) {
            const response = await fetch(`/api/user-formats/${currentUser.userId}`, {
              headers: { 'Authorization': `Bearer ${idToken}` }
            });
            if (response.ok) {
              const formats = await response.json();
              console.log("✅ Dialog opened - formats reloaded:", Object.keys(formats).length);
              setSavedFormats(formats);
              if (Object.keys(formats).length > 0) {
                console.log("📦 Formats now available in dropdown:", Object.keys(formats).join(", "));
              }
            }
          }
        } catch (err) {
          console.error("❌ Failed to reload formats on dialog open:", err);
        } finally {
          setFormatsLoading(false);
        }
      })();
    }
  }, [showImportModal, currentUser?.userId]);

  // Track if user has manually selected a format (to avoid auto-override)
  const [userSelectedFormatId, setUserSelectedFormatId] = useState<string | null>(null);

  // Auto-apply saved formats to live preview when data is pasted
  // BUT respect user's manual selection if they've chosen a specific format
  useEffect(() => {
    if (!importData.trim()) {
      setActiveFormat(null);
      setDetectedFormatLabel(null);
      return;
    }

    // If user has manually selected a format, don't auto-override
    if (userSelectedFormatId && savedFormats[userSelectedFormatId]) {
      console.log(`🔒 Respecting user's manual format selection: ${userSelectedFormatId}`);
      const userFormat = savedFormats[userSelectedFormatId];
      const currentFirstLine = importData.trim().split('\n')[0];
      const recalculatedFormat = recalculateFormatPositions(userFormat, currentFirstLine);
      setActiveFormat(recalculatedFormat);
      setDetectedFormatLabel(userFormat.label || userSelectedFormatId);
      return;
    }

    // PRIORITY 1: Auto-apply first saved format only if no manual selection
    if (Object.keys(savedFormats).length > 0 && !userSelectedFormatId) {
      // Use the first saved format automatically for live preview
      const firstFormatId = Object.keys(savedFormats)[0];
      const firstFormat = savedFormats[firstFormatId];

      // CRITICAL FIX: Recalculate positions based on current pasted data's first line
      const currentFirstLine = importData.trim().split('\n')[0];
      const recalculatedFormat = recalculateFormatPositions(firstFormat, currentFirstLine);

      const displayLabel = firstFormat.label || firstFormatId;
      console.log(`📲 Auto-applying saved format: "${displayLabel}" with recalculated positions for live preview`);
      console.log(`   Original positions:`, firstFormat.positions);
      console.log(`   Recalculated positions:`, recalculatedFormat.positions);
      setActiveFormat(recalculatedFormat);
      setDetectedFormatLabel(displayLabel);
      return;
    }

    // PRIORITY 2: Fall back to universal library detection if no saved formats
    const autoDetect = async () => {
      try {
        const firstLine = importData.trim().split('\n')[0];
        const response = await fetch('/api/broker-formats/detect', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ firstLine })
        });

        if (response.ok) {
          const data = await response.json();
          if (data.success && data.format) {
            console.log(`🎯 Auto-detected format from universal library - ${data.brokerName}: ${data.format.formatName} (${(data.confidence * 100).toFixed(0)}% confidence)`);
            setActiveFormat(data.format);
            setDetectedFormatLabel(`${data.brokerName}/${data.format.formatName}`);
          } else {
            setActiveFormat(null);
            setDetectedFormatLabel(null);
          }
        }
      } catch (error) {
        console.error('❌ Auto-detection error:', error);
        setActiveFormat(null);
        setDetectedFormatLabel(null);
      }
    };

    autoDetect();
  }, [importData, savedFormats, showImportModal, userSelectedFormatId]);

  // Broker Import State
  const [showBrokerImportModal, setShowBrokerImportModal] = useState(false);
  const [selectedBrokerForImport, setSelectedBrokerForImport] = useState<string>("");
  const [brokerCredentials, setBrokerCredentials] = useState({
    apiKey: "",
    apiSecret: "",
    clientId: "",
  });
  const [brokerImportLoading, setBrokerImportLoading] = useState(false);
  const [brokerImportError, setBrokerImportError] = useState("");

  // Order Modal State
  const [showOrderModal, setShowOrderModal] = useState(false);
  const [orderTab, setOrderTab] = useState("history");
  // Fetch broker positions when tab changes - supports all 4 brokers (Zerodha, Upstox, Angel One, Dhan)
  useEffect(() => {
    if (orderTab === "positions" && (zerodhaAccessToken || upstoxAccessToken || angelOneAccessToken || dhanAccessToken)) {
      const fetchPositions = async () => {
        setFetchingBrokerPositions(true);
        try {
          // Determine which broker is connected and get correct endpoint/token
          let endpoint = '';
          let token = '';
          let broker = '';
          
          if (zerodhaAccessToken) {
            endpoint = '/api/broker/zerodha/positions';
            token = zerodhaAccessToken;
            broker = 'Zerodha';
          } else if (upstoxAccessToken) {
            endpoint = '/api/broker/upstox/positions';
            token = upstoxAccessToken;
            broker = 'Upstox';
          } else if (angelOneAccessToken) {
            endpoint = '/api/broker/angelone/positions';
            token = angelOneAccessToken;
            broker = 'Angel One';
          } else if (dhanAccessToken) {
            endpoint = '/api/broker/dhan/positions';
            token = dhanAccessToken;
            broker = 'Dhan';
          }
          
          if (!endpoint || !token) return;
          
          const res = await fetch(endpoint, {
            headers: { 'Authorization': `Bearer ${token}` }
          });
          const data = await res.json();
          let positions = data.positions || [];

          // Fetch live prices for each position from WebSocket stream
          if (positions.length > 0) {
            const livePositions = await Promise.all(
              positions.map(async (pos: any) => {
                try {
                  const symbol = pos.symbol || '';
                  const liveRes = await fetch(`/api/live-quotes/NSE:${symbol}-EQ`);
                  if (liveRes.ok) {
                    const liveData = await liveRes.json();
                    return {
                      ...pos,
                      currentPrice: liveData.price || pos.currentPrice || pos.current_price || 0
                    };
                  }
                } catch (err) {
                  console.warn(`⚠️ [LIVE-PRICE] Could not fetch live price for ${pos.symbol}`);
                }
                return pos;
              })
            );
            positions = livePositions;
          }

          setBrokerPositions(positions);
          console.log('✅ [POSITIONS]', broker, 'Fetched', positions.length, 'positions with live prices via WebSocket');
        } catch (err) {
          console.error('❌ [POSITIONS] Error fetching positions:', err);
          setBrokerPositions([]);
        } finally {
          setFetchingBrokerPositions(false);
        }
      };

      // Fetch positions immediately when tab opens
      fetchPositions();

      // Set up polling to refresh every 700ms while tab is open
      const pollInterval = setInterval(fetchPositions, 700);

      // Cleanup: clear interval when tab changes
      return () => clearInterval(pollInterval);
    }
  }, [zerodhaAccessToken, upstoxAccessToken, angelOneAccessToken, dhanAccessToken, orderTab]);
  const [brokerOrders, setBrokerOrders] = useState<any[]>([]);
  const [fetchingBrokerOrders, setFetchingBrokerOrders] = useState(false);
  const [brokerPositions, setBrokerPositions] = useState<any[]>([]);
  const [fetchingBrokerPositions, setFetchingBrokerPositions] = useState(false);
  const [orderData, setOrderData] = useState({
    symbol: "",
    action: "Buy",
    orderType: "Market",
    quantity: "",
    price: "",
    stopLoss: "",
    target: "",
  });
  const previousBrokerOrdersLengthRef = useRef<number>(0);
  const previousCompleteOrdersLengthRef = useRef<number>(0);

  // Save Confirmation Dialog State
  const [showSaveConfirmation, setShowSaveConfirmation] = useState(false);
  const [saveConfirmationData, setSaveConfirmationData] = useState<any>(null);

  // Trade History Data State
  const [tradeHistoryData, setTradeHistoryData] = useState([]);

  // Fetch broker orders when Orders dialog opens - supports all 4 brokers (Zerodha, Upstox, Angel One, Dhan)
  useEffect(() => {
    if (orderTab === 'history' && (zerodhaAccessToken || upstoxAccessToken || angelOneAccessToken || dhanAccessToken)) {
      const fetchOrders = async () => {
        setFetchingBrokerOrders(true);
        try {
          // Determine which broker is connected and get correct endpoint/token
          let endpoint = '';
          let token = '';
          let broker = '';
          
          if (zerodhaAccessToken) {
            endpoint = '/api/broker/zerodha/trades';
            token = zerodhaAccessToken;
            broker = 'Zerodha';
          } else if (upstoxAccessToken) {
            endpoint = '/api/broker/upstox/trades';
            token = upstoxAccessToken;
            broker = 'Upstox';
          } else if (angelOneAccessToken) {
            endpoint = '/api/broker/angelone/trades';
            token = angelOneAccessToken;
            broker = 'Angel One';
          } else if (dhanAccessToken) {
            endpoint = '/api/broker/dhan/trades';
            token = dhanAccessToken;
            broker = 'Dhan';
          }
          
          if (!endpoint || !token) return;
          
          const res = await fetch(endpoint, {
            headers: { 'Authorization': `Bearer ${token}` }
          });
          const data = await res.json();
          setBrokerOrders(data.trades || []);
          console.log('✅ [ORDERS]', broker, 'Fetched', (data.trades || []).length, 'trades');
        } catch (err) {
          console.error('❌ [ORDERS] Error fetching trades:', err);
          setBrokerOrders([]);
        } finally {
          setFetchingBrokerOrders(false);
        }
      };

      // Fetch orders immediately when dialog opens
      fetchOrders();

      // Set up polling to refresh every 1 second while dialog is open
      const pollInterval = setInterval(fetchOrders, 1000);

      // Cleanup: clear interval when dialog closes
      return () => clearInterval(pollInterval);
    }
  }, [zerodhaAccessToken, upstoxAccessToken, angelOneAccessToken, dhanAccessToken, orderTab]);
// Fetch broker funds when dialog opens - with auto-refresh polling
  useEffect(() => {
    if (showOrderModal && (zerodhaAccessToken || upstoxAccessToken)) {
      const fetchBrokerFunds = async () => {
        try {
          const endpoint = zerodhaAccessToken ? '/api/broker/zerodha/margins' : '/api/broker/upstox/margins';
          const token = zerodhaAccessToken || upstoxAccessToken;
          const response = await fetch(endpoint, {
            headers: { 'Authorization': `Bearer ${token}` }
          });
          const data = await response.json();
          if (response.ok && data.success && data.availableCash !== undefined) {
            setBrokerFunds(data.availableCash);
            localStorage.setItem("zerodha_broker_funds", data.availableCash.toString());
            console.log('✅ [BROKER] Fetched available funds:', data.availableCash);
          } else {
            console.error('❌ [BROKER] Failed to fetch funds:', data.error || 'Invalid response');
            setBrokerFunds(null);
          }
        } catch (error) {
          console.error('❌ [BROKER] Failed to fetch funds:', error);
        }
      };
      
      // Fetch funds immediately when dialog opens
      fetchBrokerFunds();
      
      // Set up polling to refresh every 2 seconds while dialog is open
      const pollInterval = setInterval(fetchBrokerFunds, 2000);
      
      // Cleanup: clear interval when dialog closes
      return () => clearInterval(pollInterval);
    }
  }, [showOrderModal, zerodhaAccessToken]);

  // Restore broker funds from localStorage on mount when Zerodha connected
  useEffect(() => {
    if (zerodhaAccessToken && !brokerFunds) {
      const saved = localStorage.getItem("zerodha_broker_funds");
      if (saved) {
        setBrokerFunds(parseFloat(saved));
      }
    }
  }, [zerodhaAccessToken, brokerFunds]);

  // Fetch broker funds when dialog opens - supports all 4 brokers (Zerodha, Upstox, Angel One, Dhan)
  useEffect(() => {
    if (showOrderModal && (zerodhaAccessToken || upstoxAccessToken || angelOneAccessToken || dhanAccessToken)) {
      const fetchBrokerFunds = async () => {
        try {
          // Determine which broker is connected
          let endpoint = '';
          let token = '';
          let broker = '';
          
          if (zerodhaAccessToken) {
            endpoint = '/api/broker/zerodha/margins';
            token = zerodhaAccessToken;
            broker = 'Zerodha';
          } else if (upstoxAccessToken) {
            endpoint = '/api/broker/upstox/margins';
            token = upstoxAccessToken;
            broker = 'Upstox';
          } else if (angelOneAccessToken) {
            endpoint = '/api/broker/angelone/margins';
            token = angelOneAccessToken;
            broker = 'Angel One';
          } else if (dhanAccessToken) {
            endpoint = '/api/broker/dhan/margins';
            token = dhanAccessToken;
            broker = 'Dhan';
          }
          
          if (!endpoint || !token) return;
          
          const response = await fetch(endpoint, {
            headers: { 'Authorization': `Bearer ${token}` }
          });
          const data = await response.json();
          setBrokerFunds(data.availableCash || data.availableFunds || 0);
          console.log('✅ [FUNDS]', broker, 'Fetched available funds:', data.availableCash || data.availableFunds);
        } catch (error) {
          console.error('❌ [FUNDS] Error fetching broker funds:', error);
          setBrokerFunds(0);
        }
      };
      
      // Fetch funds immediately when dialog opens
      fetchBrokerFunds();
      
      // Set up polling to refresh every 2 seconds while dialog is open
      const pollInterval = setInterval(fetchBrokerFunds, 2000);
      
      // Cleanup: clear interval when dialog closes
      return () => clearInterval(pollInterval);
    }
  }, [showOrderModal, zerodhaAccessToken, upstoxAccessToken, angelOneAccessToken, dhanAccessToken]);

  // PAPER TRADING (DEMO TRADING) STATE - Like TradingView Practice Account
  // ============================================
  const [showPaperTradingModal, setShowPaperTradingModal] = useState(false);
  const [showTradingChallengeModal, setShowTradingChallengeModal] = useState(false); // Trading Challenge Coming Soon modal
  const [showJournalInfoModal, setShowJournalInfoModal] = useState<boolean | 'auto' | 'manual'>(false); // Trading Journal Info modal
  const [hidePositionDetails, setHidePositionDetails] = useState(false); // Eye icon toggle
  const [swipedPositionId, setSwipedPositionId] = useState<string | null>(null);
  const swipeStartXRef = useRef<number>(0);
  const swipeStartYRef = useRef<number>(0);
  const [paperTradingCapital, setPaperTradingCapital] = useState(() => {
    if (typeof window !== "undefined") {
      const stored = localStorage.getItem("paperTradingCapital");
      return stored ? parseFloat(stored) : 1800000; // 18 Lakhs default
    }
    return 1800000;
  });

  // Track cumulative realized P&L from all closed trades (persisted to AWS)
  const [paperTradingRealizedPnl, setPaperTradingRealizedPnl] = useState(() => {
    if (typeof window !== "undefined") {
      const stored = localStorage.getItem("paperTradingRealizedPnl");
      return stored ? parseFloat(stored) : 0;
    }
    return 0;
  });

  // Paper trading position interface
  interface PaperPosition {
    id: string;
    symbol: string;
    type: 'STOCK' | 'FUTURES' | 'OPTIONS';
    action: 'BUY' | 'SELL';
    quantity: number;
    entryPrice: number;
    currentPrice: number;
    entryTime: string;
    pnl: number;
    pnlPercent: number;
    isOpen: boolean;
    // Stop Loss fields
    slEnabled?: boolean;
    slType?: 'price' | 'percent' | 'duration' | 'high' | 'low';
    slValue?: string;
    slTimeframe?: string;
    slDurationUnit?: string;
    slTriggerPrice?: number;
    slExpiryTime?: number; // For duration-based SL
  }

  // Paper trading trade history
  interface PaperTrade {
    id: string;
    symbol: string;
    type: 'STOCK' | 'FUTURES' | 'OPTIONS';
    action: 'BUY' | 'SELL';
    quantity: number;
    price: number;
    time: string;
    pnl?: string;
    closedAt?: string;
  }

  const [paperPositions, setPaperPositions] = useState<PaperPosition[]>(() => {
    if (typeof window !== "undefined") {
      const stored = localStorage.getItem("paperPositions");
      return stored ? JSON.parse(stored) : [];
    }
    return [];
  });

  const [paperTradeHistory, setPaperTradeHistory] = useState<PaperTrade[]>(() => {
    if (typeof window !== "undefined") {
      const stored = localStorage.getItem("paperTradeHistory");
      return stored ? JSON.parse(stored) : [];
    }
    return [];
  });

  // AWS Paper Trading Sync State
  const [paperTradingAwsLoaded, setPaperTradingAwsLoaded] = useState(false);
  const [paperTradingAwsSaving, setPaperTradingAwsSaving] = useState(false);
  const paperTradingSaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Load paper trading data from AWS when user is authenticated
  const loadPaperTradingFromAWS = useCallback(async () => {
    const userId = localStorage.getItem('currentUserId');
    if (!userId || userId === 'null') return;

    try {
      const idToken = await getCognitoToken();
      if (!idToken) {
        console.log('⚠️ No Cognito token for paper trading AWS load');
        return;
      }

      console.log('📊 Loading paper trading data from AWS for user:', userId);
      const response = await fetch(`/api/paper-trading/${userId}`, {
        headers: { 'Authorization': `Bearer ${idToken}` }
      });

      if (response.ok) {
        const result = await response.json();
        if (result.success && result.data) {
          console.log('✅ Loaded paper trading data from AWS:', result.isNew ? '(new user, defaults)' : '');
          setPaperTradingCapital(result.data.capital || 1800000);
          setPaperPositions(result.data.positions || []);
          setPaperTradeHistory(result.data.tradeHistory || []);
          setPaperTradingRealizedPnl(result.data.realizedPnl || 0);
          // Also update localStorage for offline access
          localStorage.setItem("paperTradingCapital", String(result.data.capital || 1800000));
          localStorage.setItem("paperPositions", JSON.stringify(result.data.positions || []));
          localStorage.setItem("paperTradeHistory", JSON.stringify(result.data.tradeHistory || []));
          localStorage.setItem("paperTradingRealizedPnl", String(result.data.realizedPnl || 0));
        }
        setPaperTradingAwsLoaded(true);
      } else {
        console.warn('⚠️ Failed to load paper trading data from AWS:', response.status);
        setPaperTradingAwsLoaded(true); // Mark as loaded even on error to prevent retries
      }
    } catch (error) {
      console.error('❌ Error loading paper trading from AWS:', error);
      setPaperTradingAwsLoaded(true); // Mark as loaded even on error to prevent retries
    }
  }, []);

  // Save paper trading data to AWS (debounced)
  const savePaperTradingToAWS = useCallback(async (
    capital: number, 
    positions: PaperPosition[], 
    tradeHistory: PaperTrade[],
    realizedPnl: number
  ) => {
    const userId = localStorage.getItem('currentUserId');
    if (!userId || userId === 'null') return;

    try {
      const idToken = await getCognitoToken();
      if (!idToken) {
        console.log('⚠️ No Cognito token for paper trading AWS save');
        return;
      }

      setPaperTradingAwsSaving(true);
      const totalPnl = positions.reduce((total, p) => total + (p.pnl || 0), 0);

      const response = await fetch(`/api/paper-trading/${userId}`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${idToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          capital,
          positions,
          tradeHistory,
          totalPnl,
          realizedPnl
        })
      });

      if (response.ok) {
        console.log('✅ Paper trading data saved to AWS');
      } else {
        console.warn('⚠️ Failed to save paper trading data to AWS:', response.status);
      }
    } catch (error) {
      console.error('❌ Error saving paper trading to AWS:', error);
    } finally {
      setPaperTradingAwsSaving(false);
    }
  }, []);

  // Debounced save to AWS when paper trading data changes
  useEffect(() => {
    if (!paperTradingAwsLoaded) return; // Don't save until we've loaded from AWS

    const userId = localStorage.getItem('currentUserId');
    if (!userId || userId === 'null') return;

    // Clear any pending save
    if (paperTradingSaveTimeoutRef.current) {
      clearTimeout(paperTradingSaveTimeoutRef.current);
    }

    // Debounce save by 2 seconds to avoid too many API calls
    paperTradingSaveTimeoutRef.current = setTimeout(() => {
      savePaperTradingToAWS(paperTradingCapital, paperPositions, paperTradeHistory, paperTradingRealizedPnl);
    }, 2000);

    return () => {
      if (paperTradingSaveTimeoutRef.current) {
        clearTimeout(paperTradingSaveTimeoutRef.current);
      }
    };
  }, [paperTradingCapital, paperPositions, paperTradeHistory, paperTradingRealizedPnl, paperTradingAwsLoaded, savePaperTradingToAWS]);

  // Load paper trading data from AWS when user is authenticated
  useEffect(() => {
    const userId = localStorage.getItem('currentUserId');
    if (userId && userId !== 'null' && authInitialized && !isViewOnlyMode && !paperTradingAwsLoaded) {
      loadPaperTradingFromAWS();
    }
  }, [authInitialized, isViewOnlyMode, paperTradingAwsLoaded, loadPaperTradingFromAWS]);

  // Paper trading form state
  const [paperTradeSymbol, setPaperTradeSymbol] = useState("");
  const [paperTradeSymbolSearch, setPaperTradeSymbolSearch] = useState("");
  const [paperTradeSearchResults, setPaperTradeSearchResults] = useState<any[]>([]);
  const [paperTradeSearchLoading, setPaperTradeSearchLoading] = useState(false);
  const [selectedPaperTradingInstrument, setSelectedPaperTradingInstrument] = useState<any>(null);
  const [paperTradeType, setPaperTradeType] = useState<'STOCK' | 'FUTURES' | 'OPTIONS' | 'MCX'>('STOCK');
  const [paperTradeQuantity, setPaperTradeQuantity] = useState("");
  const [paperTradeLotInput, setPaperTradeLotInput] = useState(""); // For futures/options (multiplied by lot size)
  const [paperTradeAction, setPaperTradeAction] = useState<'BUY' | 'SELL'>('BUY');
  const [paperTradeCurrentPrice, setPaperTradeCurrentPrice] = useState<number | null>(null);
  const [paperTradePriceLoading, setPaperTradePriceLoading] = useState(false);

  // Stop Loss state
  const [showPaperTradeSLDropdown, setShowPaperTradeSLDropdown] = useState(false);
  const [showMobilePaperTradeSLDropdown, setShowMobilePaperTradeSLDropdown] = useState(false);
  const [paperTradeSLPrice, setPaperTradeSLPrice] = useState("");
  const [paperTradeSLType, setPaperTradeSLType] = useState<'price' | 'percent' | 'duration' | 'high' | 'low'>('price');
  const [paperTradeSLValue, setPaperTradeSLValue] = useState("");
  const [paperTradeSLTimeframe, setPaperTradeSLTimeframe] = useState("5m");
  const [paperTradeSLDurationUnit, setPaperTradeSLDurationUnit] = useState("min");
  const [paperTradeSLEnabled, setPaperTradeSLEnabled] = useState(false); // SL is enabled when user sets it
  const paperTradingStreamSymbolsRef = useRef<Set<string>>(new Set());

  // Paper trading LIVE WebSocket streaming state (TradingView-style real-time P&L)
  const [paperTradingWsStatus, setPaperTradingWsStatus] = useState<'connected' | 'connecting' | 'disconnected'>('disconnected');
  const [paperTradingLivePrices, setPaperTradingLivePrices] = useState<Map<string, number>>(new Map());
  const paperTradingEventSourcesRef = useRef<Map<string, EventSource>>(new Map());
  const paperTradingLastUpdateRef = useRef<number>(Date.now());

  // 🔴 CRITICAL FIX: Sync live prices from WebSocket stream to paper positions immediately
  // This ensures that when a new position is opened, its LTP updates instantly as prices stream in
  useEffect(() => {
    if (paperTradingLivePrices.size === 0 || paperPositions.length === 0) return;

    const updatedPositions = paperPositions.map(position => {
      const livePrice = paperTradingLivePrices.get(position.symbol);
      if (livePrice && livePrice !== position.currentPrice) {
        const pnl = (livePrice - position.entryPrice) * position.quantity;
        const pnlPercent = ((livePrice - position.entryPrice) / position.entryPrice) * 100;
        return {
          ...position,
          currentPrice: livePrice,
          pnl: position.action === "BUY" ? pnl : -pnl,
          pnlPercent: position.action === "BUY" ? pnlPercent : -pnlPercent
        };
      }
      return position;
    });

    if (JSON.stringify(updatedPositions) !== JSON.stringify(paperPositions)) {
      setPaperPositions(updatedPositions);
    }
  }, [paperTradingLivePrices]);
  // Map paper trade type to exchange segment for filtering
  const getExchangeForTradeType = (type: 'STOCK' | 'FUTURES' | 'OPTIONS' | 'MCX'): string => {
    switch (type) {
      case 'STOCK':
        return 'NSE,BSE';  // Equity stocks
      case 'FUTURES':
        return 'NFO,BFO';  // NSE F&O + BSE F&O for futures
      case 'OPTIONS':
        return 'NFO,BFO';  // NSE F&O + BSE F&O for options
      case 'MCX':
        return 'MCX,NCDEX';  // MCX + NCDEX for commodities
      default:
        return 'NSE,BSE';
    }
  };

  // Get lot size for Angel One instruments based on API standards
  const getLotSizeForInstrument = (symbol: string, type: 'STOCK' | 'FUTURES' | 'OPTIONS' | 'MCX'): number => {

    // Current lot sizes (effective now)

    // NSE Futures lot sizes - CURRENT
    const futuresLotSizes: { [key: string]: number } = {
      'NIFTY': 75,          // 1 lot = 75 qty
      'BANKNIFTY': 35,      // 1 lot = 35 qty
      'FINNIFTY': 65,       // 1 lot = 65 qty
      'MIDCPNIFTY': 40,     // 1 lot = 40 qty
      'SENSEX': 20,         // 1 lot = 20 qty (BSE)
      'BANKEX': 15,         // 1 lot = 15 qty (BSE)
      'NIFTYIT': 50,
      'NIFTYPHARMA': 50,
      'NIFTYINFRA': 50,
      'NIFTYAUTO': 50,
      'NIFTYBANK': 50,
    };

    // MCX lot sizes (in units)
    const mcxLotSizes: { [key: string]: number } = {
      'GOLD': 100,      // 100 grams
      'SILVER': 30,     // 30 kg
      'CRUDEOIL': 100,  // 100 barrels
      'NATURALGAS': 250, // 250 MMBtu
      'COPPER': 1,      // 1 MT
      'LEAD': 1,        // 1 MT
      'NICKEL': 1,      // 1 MT
      'ZINC': 1,        // 1 MT
      'ALUMMINI': 1,    // 1 MT
      'COTTON': 1,      // 1 bale
      'MENTHAOIL': 1,   // 1 MT
    };

    // NCDEX lot sizes
    const ncdexLotSizes: { [key: string]: number } = {
      'TURMERIC': 1,
      'MAIZE': 100,
      'SOYBEANGRDER': 100,
      'SOYBEAN': 100,
      'MUSTARD': 100,
      'CARDAMOM': 1,
      'PEPPER': 1,
      'DHANIYA': 100,
    };

    // Extract base symbol: remove everything from first digit onwards
    // E.g., "BANKNIFTY30DEC25FUT" → "BANKNIFTY"
    const baseSymbol = symbol.replace(/\d.*$/i, '').toUpperCase();

    switch (type) {
      case 'FUTURES':
        return futuresLotSizes[baseSymbol] || 1;
      case 'OPTIONS':
        return futuresLotSizes[baseSymbol] || 1; // Options use same lot size as underlying futures
      case 'MCX':
        return mcxLotSizes[baseSymbol] || 1;
      case 'STOCK':
      default:
        return 1; // Stocks can be bought in any quantity
    }
  };

  // Get placeholder text based on selected type
  const getSearchPlaceholder = (): string => {
    switch (paperTradeType) {
      case 'STOCK':
        return 'Search RELIANCE, TCS, INFY...';
      case 'FUTURES':
        return 'Search NIFTY, BANKNIFTY futures...';
      case 'OPTIONS':
        return 'Search NIFTY, BANKNIFTY options...';
      case 'MCX':
        return 'Search GOLD, SILVER, CRUDEOIL...';
      default:
        return 'Search instruments...';
    }
  };

  // Sort instruments by category: Index -> Futures (near, next, far) -> Options
  const sortInstruments = (instruments: any[]): any[] => {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Categorize instruments
    const categories: any = {
      index: [],
      futuresNear: [],
      futuresNext: [],
      futuresFar: [],
      options: [],
      others: []
    };

    instruments.forEach((inst) => {
      const instrumentType = inst.instrumentType || '';

      // Check if it's an index (NIFTY50, NIFTY, BANKNIFTY, etc)
      if (instrumentType === 'FUTIDX' || instrumentType === 'OPTIDX' || 
          inst.symbol?.match(/^(NIFTY50|NIFTY|BANKNIFTY|FINNIFTY|MIDCPNIFTY)$/i)) {
        if (instrumentType === 'OPTIDX') {
          categories.options.push(inst);
        } else {
          categories.index.push(inst);
        }
      }
      // Check if it's a future
      else if (instrumentType === 'FUTSTK' || instrumentType === 'FUTIDX' || instrumentType === 'FUTCOM') {
        if (inst.expiry) {
          const expiryDate = new Date(inst.expiry);
          expiryDate.setHours(0, 0, 0, 0);
          const daysUntilExpiry = Math.floor((expiryDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));

          if (daysUntilExpiry <= 7) {
            categories.futuresNear.push(inst);
          } else if (daysUntilExpiry <= 37) {
            categories.futuresNext.push(inst);
          } else {
            categories.futuresFar.push(inst);
          }
        } else {
          categories.futuresNear.push(inst);
        }
      }
      // Check if it's an option
      else if (instrumentType === 'OPTSTK' || instrumentType === 'OPTFUT' || instrumentType === 'OPTIDX') {
        categories.options.push(inst);
      }
      // Everything else
      else {
        categories.others.push(inst);
      }
    });

    // Combine in order: Index -> Futures Near -> Futures Next -> Futures Far -> Options -> Others
    return [
      ...categories.index,
      ...categories.futuresNear,
      ...categories.futuresNext,
      ...categories.futuresFar,
      ...categories.options,
      ...categories.others
    ];
  };

  // Dynamic search for paper trading instruments filtered by type/exchange
  const searchPaperTradingInstruments = async (query: string) => {
    if (!query || query.length < 1) {
      setPaperTradeSearchResults([]);
      return;
    }

    setPaperTradeSearchLoading(true);
    try {
      // Get exchange segment based on selected trade type
      const exchange = getExchangeForTradeType(paperTradeType);
      console.log(`🔍 [PAPER-TRADE] Searching for "${query}" on exchange: ${exchange} (type: ${paperTradeType})`);

      const url = `/api/angelone/search-instruments?query=${encodeURIComponent(query)}&exchange=${encodeURIComponent(exchange)}&limit=50`;
      console.log(`🔍 [PAPER-TRADE] API URL: ${url}`);

      const response = await fetch(url);

      if (response.ok) {
        const data = await response.json();
        console.log(`🔍 [PAPER-TRADE] API Response:`, data);
        const instruments = data.instruments || data.results || [];
        console.log(`🔍 [PAPER-TRADE] Found ${instruments.length} instruments`);

        // Format instruments for display
        const formatted = instruments.map((inst: any) => ({
          symbol: inst.symbol || inst.tradingSymbol || "",
          name: inst.name || inst.symbol || "",
          token: inst.token || inst.symbolToken || "",
          exchange: inst.exchange || "",
          instrumentType: inst.instrumentType || "",
          type: inst.type || paperTradeType,
          lotSize: inst.lotSize || 1,
          expiry: inst.expiry || null,
        }));

        // Sort by category (Index -> Futures near/next/far -> Options)
        const sorted = sortInstruments(formatted);

        console.log(`🔍 [PAPER-TRADE] Formatted and sorted ${sorted.length} results:`, sorted.slice(0, 3));
        sorted.forEach((inst, idx) => {
          if (idx < 3) {
            console.log(`  [${idx}] ${inst.symbol} | Token: ${inst.token} | Exchange: ${inst.exchange} | Type: ${inst.instrumentType}`);
          }
        });
        setPaperTradeSearchResults(sorted);
      } else {
        console.error(`🔍 [PAPER-TRADE] API error: ${response.status}`);
        setPaperTradeSearchResults([]);
      }
    } catch (error) {
      console.error("Paper trading search error:", error);
      setPaperTradeSearchResults([]);
    } finally {
      setPaperTradeSearchLoading(false);
    }
  };

  // 🔴 FIX: Keep paper trading WebSocket OPEN for continuous 700ms streaming (not just first price!)
  const fetchPaperTradePrice = async (stockInfoOverride?: any) => {
    const stockInfo = stockInfoOverride || selectedPaperTradingInstrument;

    if (!stockInfo) {
      console.warn(`⚠️ [PAPER-TRADE-PRICE] No instrument selected`);
      return;
    }

    // Close previous stream if any
    if (paperTradingEventSourcesRef.current.has(stockInfo.symbol)) {
      const prevStream = paperTradingEventSourcesRef.current.get(stockInfo.symbol);
      if (prevStream) prevStream.close();
      paperTradingEventSourcesRef.current.delete(stockInfo.symbol);
    }

    console.log(`🔍 [PAPER-TRADE-PRICE] Selected instrument:`, {
      symbol: stockInfo.symbol,
      token: stockInfo.token,
      exchange: stockInfo.exchange,
      instrumentType: stockInfo.instrumentType,
      type: stockInfo.type
    });

    // Validate required fields
    if (!stockInfo.symbol || !stockInfo.exchange) {
      console.error(`❌ [PAPER-TRADE-PRICE] Missing required fields:`, {
        symbol: stockInfo.symbol,
        token: stockInfo.token,
        exchange: stockInfo.exchange
      });
      setPaperTradePriceLoading(false);
      return;
    }

    setPaperTradePriceLoading(true);
    setPaperTradingWsStatus('connecting');
    try {
      // 🔴 CRITICAL FIX: Stream continuous live prices at 700ms (tick data!)
      // Using interval=0 to get raw tick updates from Angel One, NOT binned candles
      const sseUrl = `/api/angelone/live-stream-ws?symbol=${stockInfo.symbol}&symbolToken=${stockInfo.token}&exchange=${stockInfo.exchange}&tradingSymbol=${stockInfo.symbol}&interval=0`; // 0 = live tick data at 700ms

      console.log(`📊 [PAPER-TRADE-PRICE] Opening CONTINUOUS live price stream for ${stockInfo.symbol} (NSE, BSE, MCX, NCDEX, NFO, BFO, CDS)`);
      console.log(`  URL: ${sseUrl}`);

      const eventSource = new EventSource(sseUrl);
      paperTradingEventSourcesRef.current.set(stockInfo.symbol, eventSource);

      let priceReceived = false;
      const timeout = setTimeout(() => {
        if (!priceReceived) {
          console.warn(`⚠️ [PAPER-TRADE-PRICE] No price received for ${stockInfo.symbol} after 5s`);
          setPaperTradePriceLoading(false);
        }
      }, 5000);

      eventSource.onopen = () => {
        console.log(`✅ [PAPER-TRADE-PRICE] WebSocket STREAMING for ${stockInfo.symbol} @ 700ms`);
        setPaperTradingWsStatus('connected');
      };

      eventSource.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          const ltp = data.ltp || data.close;

          if (ltp && ltp > 0) {
            if (!priceReceived) {
              console.log(`✅ [PAPER-TRADE-PRICE] Got initial price for ${stockInfo.symbol}: ₹${ltp}`);
              clearTimeout(timeout);
              setPaperTradePriceLoading(false);
              priceReceived = true;
            }
            // 🔴 CRITICAL: Keep connection OPEN and update continuously (not close!)
            setPaperTradeCurrentPrice(ltp);
            setPaperTradingLivePrices(prev => new Map(prev).set(stockInfo.symbol, ltp));
          }
        } catch (err) {
          console.error(`[PAPER-TRADE-PRICE] Parse error for ${stockInfo.symbol}:`, err);
        }
      };

      eventSource.onerror = (event) => {
        console.error(`❌ [PAPER-TRADE-PRICE] Connection error for ${stockInfo.symbol}:`, event);
        clearTimeout(timeout);
        eventSource.close();
        paperTradingEventSourcesRef.current.delete(stockInfo.symbol);
        setPaperTradingWsStatus('disconnected');
        if (!priceReceived) {
          setPaperTradePriceLoading(false);
        }
      };
    } catch (error) {
      console.error("❌ [PAPER-TRADE-PRICE] Exception:", error);
      setPaperTradePriceLoading(false);
      setPaperTradingWsStatus('disconnected');
    }
  };

  // Execute paper trade (BUY or SELL)
  const executePaperTrade = () => {
    const inputValue = paperTradeType === 'STOCK' ? paperTradeQuantity : paperTradeLotInput;
    if (!paperTradeSymbol || !inputValue || !paperTradeCurrentPrice) {
      toast({
        title: "Invalid Trade",
        description: `Please select a symbol and enter ${paperTradeType === 'STOCK' ? 'quantity' : 'lots'}`,
        variant: "destructive"
      });
      return;
    }

    // Calculate quantity: for stocks it's direct, for futures/options it's lots * lot size
    let quantity = parseInt(inputValue);
    if (paperTradeType !== 'STOCK') {
      const lotSize = getLotSizeForInstrument(paperTradeSymbol, paperTradeType);
      quantity = quantity * lotSize;
    }
    const tradeValue = quantity * paperTradeCurrentPrice;

    if (paperTradeAction === 'BUY') {
      // Check if enough capital
      if (tradeValue > paperTradingCapital) {
        toast({
          title: "Insufficient Capital",
          description: `Need ₹${tradeValue.toLocaleString()} but only ₹${paperTradingCapital.toLocaleString()} available`,
          variant: "destructive"
        });
        return;
      }

      // Calculate SL trigger price if SL is enabled
      let slTriggerPrice: number | undefined;
      let slExpiryTime: number | undefined;

      if (paperTradeSLEnabled && paperTradeSLValue) {
        if (paperTradeSLType === 'price') {
          slTriggerPrice = parseFloat(paperTradeSLValue);
        } else if (paperTradeSLType === 'percent') {
          const percentValue = parseFloat(paperTradeSLValue);
          slTriggerPrice = paperTradeCurrentPrice * (1 - percentValue / 100);
        } else if (paperTradeSLType === 'duration') {
          const durationValue = parseFloat(paperTradeSLValue);
          const multiplier = paperTradeSLDurationUnit === 'hr' ? 60 : 1;
          slExpiryTime = Date.now() + (durationValue * multiplier * 60 * 1000);
        }
      }

      // Create new position
      const newPosition: PaperPosition = {
        id: `PT-${Date.now()}`,
        symbol: paperTradeSymbol,
        type: paperTradeType as any,
        action: 'BUY',
        quantity: quantity,
        entryPrice: paperTradeCurrentPrice,
        currentPrice: paperTradeCurrentPrice,
        entryTime: new Date().toLocaleTimeString(),
        pnl: 0,
        pnlPercent: 0,
        isOpen: true,
        // Store token and exchange for WebSocket live price streaming
        symbolToken: (selectedPaperTradingInstrument as any)?.token || "0",
        exchange: (selectedPaperTradingInstrument as any)?.exchange || (paperTradeType === 'MCX' ? 'MCX' : paperTradeType === 'FUTURES' || paperTradeType === 'OPTIONS' ? 'NFO' : 'NSE'),
        // Stop Loss settings
        slEnabled: paperTradeSLEnabled,
        slType: paperTradeSLEnabled ? paperTradeSLType : undefined,
        slValue: paperTradeSLEnabled ? paperTradeSLValue : undefined,
        slTimeframe: paperTradeSLEnabled ? paperTradeSLTimeframe : undefined,
        slDurationUnit: paperTradeSLEnabled ? paperTradeSLDurationUnit : undefined,
        slTriggerPrice: slTriggerPrice,
        slExpiryTime: slExpiryTime
      } as any;

      // Add to positions
      const updatedPositions = [...paperPositions, newPosition];
      setPaperPositions(updatedPositions);
      localStorage.setItem("paperPositions", JSON.stringify(updatedPositions));

      // 🔴 CRITICAL: Start live price streaming for the new position
      const instrumentForStreaming = {
        symbol: newPosition.symbol,
        exchange: newPosition.exchange,
        token: newPosition.symbolToken,
        name: newPosition.symbol
      };
      fetchPaperTradePrice(instrumentForStreaming);

      // Deduct from capital
      const newCapital = paperTradingCapital - tradeValue;
      setPaperTradingCapital(newCapital);
      localStorage.setItem("paperTradingCapital", String(newCapital));

      // Add to trade history
      const newTrade: PaperTrade = {
        id: newPosition.id,
        symbol: paperTradeSymbol,
        type: 'MIS',
        action: 'BUY',
        quantity: quantity,
        price: paperTradeCurrentPrice,
        time: new Date().toLocaleTimeString()
      };
      const updatedHistory = [...paperTradeHistory, newTrade];
      setPaperTradeHistory(updatedHistory);
      localStorage.setItem("paperTradeHistory", JSON.stringify(updatedHistory));

      // Build toast message with SL info
      let toastDescription = `Bought ${quantity} ${paperTradeSymbol} @ ₹${paperTradeCurrentPrice.toFixed(2)}`;
      if (paperTradeSLEnabled && slTriggerPrice) {
        toastDescription += ` | SL: ₹${slTriggerPrice.toFixed(2)}`;
      } else if (paperTradeSLEnabled && slExpiryTime) {
        toastDescription += ` | SL: ${paperTradeSLValue} ${paperTradeSLDurationUnit}`;
      }

      toast({
        title: "Trade Executed",
        description: toastDescription
      });

      // Reset SL settings after trade
      setPaperTradeSLEnabled(false);
      setPaperTradeSLValue("");
      setShowPaperTradeSLDropdown(false);

    } else {
      // SELL - Close an existing position
      const openPosition = paperPositions.find(p => p.symbol === paperTradeSymbol && p.isOpen);

      if (!openPosition) {
        toast({
          title: "No Open Position",
          description: `You don't have an open position in ${paperTradeSymbol} to sell`,
          variant: "destructive"
        });
        return;
      }

      // Calculate P&L
      const pnl = (paperTradeCurrentPrice - openPosition.entryPrice) * openPosition.quantity;
      const pnlPercent = ((paperTradeCurrentPrice - openPosition.entryPrice) / openPosition.entryPrice) * 100;

      // Close the position
      const updatedPositions = paperPositions.map(p => 
        p.id === openPosition.id 
          ? { 
              ...p, 
              isOpen: false, 
              currentPrice: paperTradeCurrentPrice, 
              pnl, 
              pnlPercent,
              // Preserve token and exchange for logging
              symbolToken: (p as any).symbolToken,
              exchange: (p as any).exchange
            }
          : p
      );
      setPaperPositions(updatedPositions);
      localStorage.setItem("paperPositions", JSON.stringify(updatedPositions));

      // Add sale value back to capital plus P&L
      const saleValue = openPosition.quantity * paperTradeCurrentPrice;
      const newCapital = paperTradingCapital + saleValue;
      setPaperTradingCapital(newCapital);
      localStorage.setItem("paperTradingCapital", String(newCapital));

      // Add sell trade to history
      const sellTrade: PaperTrade = {
        id: `PT-${Date.now()}`,
        symbol: paperTradeSymbol,
        type: 'MIS',
        action: 'SELL',
        quantity: openPosition.quantity,
        price: paperTradeCurrentPrice,
        time: new Date().toLocaleTimeString(),
        pnl: `₹${pnl.toFixed(2)}`,
        closedAt: new Date().toLocaleTimeString()
      };
      const updatedHistory = [...paperTradeHistory, sellTrade];
      setPaperTradeHistory(updatedHistory);
      localStorage.setItem("paperTradeHistory", JSON.stringify(updatedHistory));

      toast({
        title: pnl >= 0 ? "Profit Booked!" : "Loss Booked",
        description: `Sold ${openPosition.quantity} ${paperTradeSymbol} @ ₹${paperTradeCurrentPrice.toFixed(2)} | P&L: ₹${pnl.toFixed(2)}`
      });
    }

    // Reset form
    setPaperTradeSymbol("");
    setPaperTradeQuantity("");
    setPaperTradeLotInput("");
    setPaperTradeCurrentPrice(null);
    setPaperTradeSymbolSearch("");
  };

  // Reset paper trading account
  const resetPaperTradingAccount = async () => {
    setPaperTradingCapital(1800000);
    setPaperPositions([]);
    setPaperTradeHistory([]);
    setPaperTradeSymbol("");
    setPaperTradeQuantity("");
    setPaperTradeLotInput("");
    setPaperTradeCurrentPrice(null);
    localStorage.setItem("paperTradingCapital", "1800000");
    localStorage.setItem("paperPositions", "[]");
    localStorage.setItem("paperTradeHistory", "[]");
    setPaperTradingRealizedPnl(0);
    localStorage.setItem("paperTradingRealizedPnl", "0");
    // Reset AWS data
    setPaperTradingAwsLoaded(false);
    const userId = localStorage.getItem('currentUserId');
    if (userId && userId !== 'null') {
      try {
        const idToken = await getCognitoToken();
        if (idToken) {
          await fetch(`/api/paper-trading/${userId}`, {
            method: 'DELETE',
            headers: { 'Authorization': `Bearer ${idToken}` }
          });
          console.log('✅ Paper trading AWS data reset');
        }
      } catch (error) {
        console.error('❌ Error resetting AWS paper trading data:', error);
      }
      setPaperTradingAwsLoaded(true);
    }
    toast({
      title: "Account Reset",
      description: "Paper trading account reset to ₹18,00,000"
    });
  };

  // 🔴 NEW: Record all paper trades - opens Trade History Summary (like Import P&L does)
  const recordAllPaperTrades = () => {
    if (paperTradeHistory.length === 0) {
      toast({
        title: "No Trades",
        description: "No trade history to record",
        variant: "destructive"
      });
      return;
    }


    // 🔴 AUTO-SWITCH to personal mode if in demo - record trades immediately in single tap
    if (isDemoMode) {
      console.log("🔄 Auto-switching to personal mode to record trades...");
      setIsDemoMode(false);
    }


    console.log("📊 Converting paper trades to journal format...");

    // Convert paper trades to trade journal format (time, order, symbol, type, qty, price)
    const convertedTrades = paperTradeHistory.map((trade: any) => ({
      time: trade.time,
      order: trade.action, // BUY or SELL
      symbol: trade.symbol,
      type: trade.type || 'MIS',
      qty: trade.quantity,
      price: trade.price,
      pnl: trade.pnl || '-',
      duration: trade.closedAt ? '0m 0s' : '-'
    }));

    // 1️⃣ Calculate P&L (same as Import P&L does)
    const processedData = calculateSimplePnL(convertedTrades);

    // 2️⃣ Add to trade history summary (opens the summary window)
    setTradeHistoryData(processedData); // Reset history with new trades only

    // 3️⃣ Also record to today's personal heatmap for tracking
    const today = new Date();
    const todayKey = formatDateKey(today);
    const existingData = tradingDataByDate[todayKey] || {};
    const existingTrades = existingData.tradeHistory || [];

    // Convert for heatmap storage (different format)
    const heatmapTrades = paperTradeHistory.map((trade: any) => ({
      symbol: trade.symbol,
      type: trade.type || 'MIS',
      action: trade.action,
      quantity: trade.quantity,
      price: trade.price,
      time: trade.time,
      pnl: trade.pnl,
      closedAt: trade.closedAt
    }));

    const mergedTrades = [...existingTrades, ...heatmapTrades];
    const updatedData = {
      ...existingData,
      tradeHistory: mergedTrades,
      profitLossAmount: mergedTrades.reduce((sum: number, trade: any) => {
        if (trade.pnl && trade.pnl !== '-') {
          const pnlStr = String(trade.pnl).replace('₹', '').replace('+', '');
          return sum + (parseFloat(pnlStr) || 0);
        }
        return sum;
      }, 0),
      totalTrades: mergedTrades.length
    };

    setPersonalTradingDataByDate((prev: any) => ({
      ...prev,
      [todayKey]: updatedData
    }));

    localStorage.setItem("personalTradingDataByDate", JSON.stringify({
      ...personalTradingDataByDate,
      [todayKey]: updatedData
    }));

    // 4️⃣ Auto-select today's date on both heatmap AND journal calendar
    setHeatmapSelectedDate(todayKey);
    setSelectedDate(today);

    // 5️⃣ Close paper trading dialog and show summary
    setShowPaperTradingModal(false);
    setIsDemoMode(false);

    toast({
      title: "Trades Recorded",
      description: `Recorded ${convertedTrades.length} trades to today's summary and personal tradebook`
    });

    console.log("✅ Paper trades recorded to journal summary and heatmap");

    // 🔄 Trigger PersonalHeatmap refresh to immediately display colors after save
    setPersonalHeatmapRevision(prev => prev + 1);
  };


  // 🔴 NEW: Record all broker orders to journal (same flow as paper trading)
  const recordAllBrokerOrders = () => {
    if (brokerOrders.length === 0) {
      toast({
        title: "No Orders",
        description: "No broker orders to record",
        variant: "destructive"
      });
      return;
    }

    // Filter to only COMPLETE orders (successful orders only)
    const completeOrders = brokerOrders.filter((order: any) => order.status === 'COMPLETE');
    
    if (completeOrders.length === 0) {
      toast({
        title: "No Complete Orders",
        description: "Only COMPLETE orders are imported. Skipping REJECTED, CANCELLED, and PENDING orders.",
        variant: "destructive"
      });
      return;
    }

    if (isDemoMode) {
      console.log("🔄 Auto-switching to personal mode to record broker orders...");
      setIsDemoMode(false);
    }

    console.log("📊 Converting broker orders to journal format (COMPLETE orders only)...");
    console.log(`✅ Importing ${completeOrders.length} COMPLETE orders (skipped ${brokerOrders.length - completeOrders.length} non-complete orders)`);

    const convertedTrades = completeOrders.map((trade: any) => ({
      time: trade.time,
      order: trade.order,
      symbol: trade.symbol,
      type: trade.type || 'MIS',
      qty: trade.qty,
      price: trade.price,
      pnl: trade.pnl || '-',
      duration: trade.duration || '-'
    }));

    const processedData = calculateSimplePnL(convertedTrades);
    setTradeHistoryData(processedData);

    const today = new Date();
    const todayKey = formatDateKey(today);
    const existingData = tradingDataByDate[todayKey] || {};
    const existingTrades = existingData.tradeHistory || [];

    const heatmapTrades = completeOrders.map((trade: any) => ({
      symbol: trade.symbol,
      type: trade.type || 'MIS',
      action: trade.order,
      quantity: trade.qty,
      price: trade.price,
      time: trade.time,
      pnl: trade.pnl,
      duration: trade.duration
    }));

    const mergedTrades = [...existingTrades, ...heatmapTrades];
    const updatedData = {
      ...existingData,
      tradeHistory: mergedTrades,
      profitLossAmount: mergedTrades.reduce((sum: number, trade: any) => {
        if (trade.pnl && trade.pnl !== '-') {
          const pnlStr = String(trade.pnl).replace('₹', '').replace('+', '');
          return sum + (parseFloat(pnlStr) || 0);
        }
        return sum;
      }, 0),
      totalTrades: mergedTrades.length
    };

    setPersonalTradingDataByDate((prev: any) => ({...prev, [todayKey]: updatedData}));
    localStorage.setItem("personalTradingDataByDate", JSON.stringify({...personalTradingDataByDate, [todayKey]: updatedData}));

    setHeatmapSelectedDate(todayKey);
    setSelectedDate(today);
    setShowOrderModal(false);

    toast({
      title: "Orders Recorded",
      description: `Recorded ${completeOrders.length} orders`
    });

    console.log("✅ Broker orders recorded to journal summary and heatmap");
    setPersonalHeatmapRevision(prev => prev + 1);
  };

  // Exit all open positions at once

  // Auto-tap: Automatically record broker orders when NEW COMPLETE orders are added
  useEffect(() => {
    // Count only COMPLETE orders
    const completeOrders = brokerOrders.filter((order: any) => order.status === 'COMPLETE');
    const completeOrdersCount = completeOrders.length;
    
    // Only auto-trigger if COMPLETE count increased (new success orders added)
    if (completeOrdersCount > previousCompleteOrdersLengthRef.current && completeOrdersCount > 0) {
      console.log(`🤖 [AUTO-TAP] Detected ${completeOrdersCount} COMPLETE orders (was ${previousCompleteOrdersLengthRef.current}), auto-recording only success orders...`);
      
      // Schedule the auto-record for next tick to ensure state is updated
      setTimeout(() => {
        recordAllBrokerOrders();
      }, 500);
    }
    
    // Update the ref with current COMPLETE orders count
    previousCompleteOrdersLengthRef.current = completeOrdersCount;
    
    // Keep tracking total for reference (but don't use for trigger)
    previousBrokerOrdersLengthRef.current = brokerOrders.length;
  }, [brokerOrders]);
  const exitAllPaperPositions = () => {
    if (openPositions.length === 0) {
      toast({
        title: "No Positions",
        description: "No open positions to exit",
        variant: "destructive"
      });
      return;
    }

    let totalPnl = 0;
    let newCapital = paperTradingCapital;
    const newHistoryEntries: PaperTrade[] = [];
    const exitTime = new Date().toLocaleTimeString();

    // Close all positions and calculate total P&L
    const updatedPositions = paperPositions.map(p => {
      if (!p.isOpen) return p;

      // Calculate P&L for this position
      const pnl = (p.currentPrice - p.entryPrice) * p.quantity;
      const pnlPercent = ((p.currentPrice - p.entryPrice) / p.entryPrice) * 100;
      totalPnl += pnl;

      // Add sale value back to capital
      const saleValue = p.quantity * p.currentPrice;
      newCapital += saleValue;

      // Create sell trade entry for history
      const sellTrade: PaperTrade = {
        id: `PT-EXIT-${Date.now()}-${p.id}`,
        symbol: p.symbol,
        type: p.type,
        action: 'SELL',
        quantity: p.quantity,
        price: p.currentPrice,
        time: exitTime,
        pnl: `₹${pnl.toFixed(2)}`,
        closedAt: exitTime
      };
      newHistoryEntries.push(sellTrade);

      // Return closed position
      return {
        ...p,
        isOpen: false,
        pnl,
        pnlPercent
      };
    });

    // Update positions
    setPaperPositions(updatedPositions);
    localStorage.setItem("paperPositions", JSON.stringify(updatedPositions));

    // Update capital
    setPaperTradingCapital(newCapital);
    localStorage.setItem("paperTradingCapital", String(newCapital));

    // Add all sell trades to history
    const updatedHistory = [...paperTradeHistory, ...newHistoryEntries];
    setPaperTradeHistory(updatedHistory);
    localStorage.setItem("paperTradeHistory", JSON.stringify(updatedHistory));

    // Accumulate realized P&L from all closed positions
    setPaperTradingRealizedPnl(prev => {
      const newRealizedPnl = prev + totalPnl;
      localStorage.setItem("paperTradingRealizedPnl", String(newRealizedPnl));
      return newRealizedPnl;
    });

    // Show toast with summary
    toast({
      title: totalPnl >= 0 ? "All Positions Closed - Profit!" : "All Positions Closed - Loss",
      description: `Exited ${openPositions.length} position${openPositions.length > 1 ? 's' : ''} | Total P&L: ${totalPnl >= 0 ? '+' : ''}₹${totalPnl.toFixed(2)}`
    });
  };

  const exitPosition = (positionId: string) => {
    const position = paperPositions.find(p => p.id === positionId);

    if (!position) {
      toast({
        title: "Position Not Found",
        description: "Could not find the position to exit",
        variant: "destructive"
      });
      return;
    }

    const exitPnL = position.pnl;
    const exitPrice = position.currentPrice;

    // Update position as closed
    const updatedPositions = paperPositions.map(p =>
      p.id === positionId ? { ...p, isOpen: false } : p
    );
    setPaperPositions(updatedPositions);
    localStorage.setItem("paperPositions", JSON.stringify(updatedPositions));

    // Add to trade history
    const newTrade: PaperTrade = {
      id: `exit-${positionId}`,
      symbol: position.symbol,
      type: position.type,
      action: position.action === 'BUY' ? 'SELL' : 'BUY', // Exit action is opposite of entry
      quantity: position.quantity,
      price: exitPrice,
      time: new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' }),
      pnl: `${exitPnL >= 0 ? '+' : ''}₹${exitPnL.toFixed(0)}`,
      closedAt: new Date().toISOString()
    };

    const updatedHistory = [...paperTradeHistory, newTrade];
    setPaperTradeHistory(updatedHistory);
    localStorage.setItem("paperTradeHistory", JSON.stringify(updatedHistory));

    // Accumulate realized P&L from closed position
    setPaperTradingRealizedPnl(prev => {
      const newRealizedPnl = prev + exitPnL;
      localStorage.setItem("paperTradingRealizedPnl", String(newRealizedPnl));
      return newRealizedPnl;
    });

    setSwipedPositionId(null);

    toast({
      title: "Position Exited",
      description: `${position.symbol} exited at ₹${exitPrice.toFixed(2)} | P&L: ₹${exitPnL.toFixed(0)}`,
      duration: 2000
    });
  };

  // Persist paper trading positions to localStorage when they change
  useEffect(() => {
    localStorage.setItem("paperPositions", JSON.stringify(paperPositions));
  }, [paperPositions]);

  // ============================================
  // PAPER TRADING LIVE WEBSOCKET STREAMING (TradingView-style real-time P&L)
  // Uses same SSE stream as journal chart for live 700ms price updates
  // ============================================
  useEffect(() => {
    // Only stream when modal is open OR mobile paper trading tab is active, and there are open positions
    const openPositions = paperPositions.filter(p => p.isOpen);
    const openSymbols = new Set(openPositions.map(p => p.symbol));

    // Check if paper trading is active (either desktop modal OR mobile tab)
    const isMobilePaperTradeTabActive = activeTab === 'journal' && mobileBottomTab === 'paper-trade';
    const isPaperTradingActive = showPaperTradingModal || isMobilePaperTradeTabActive;

    if (!isPaperTradingActive || openPositions.length === 0) {
      // Clean up all existing connections
      paperTradingEventSourcesRef.current.forEach((es) => {
        es.close();
      });
      paperTradingEventSourcesRef.current.clear();
      setPaperTradingWsStatus('disconnected');
      return;
    }

    // Clean up stale connections (positions that were closed)
    paperTradingEventSourcesRef.current.forEach((es, symbol) => {
      if (!openSymbols.has(symbol)) {
        console.log(`🔌 [PAPER-TRADING] Closing stale connection: ${symbol}`);
        es.close();
        paperTradingEventSourcesRef.current.delete(symbol);
      }
    });

    setPaperTradingWsStatus('connecting');
    console.log(`📊 [PAPER-TRADING] Starting live stream for ${openPositions.length} positions`);

    // Subscribe to live stream for each open position
    openPositions.forEach(position => {
      // Skip if already connected
      if (paperTradingEventSourcesRef.current.has(position.symbol)) return;

      // For open positions, we store symbol, token, exchange in the position data
      // Or fetch it from search results if available
      const symbolToken = (position as any).symbolToken || "0";
      const exchange = (position as any).exchange || "NSE";

      // 🔴 Use 700ms live tick stream for instant P&L updates (same as initial price fetch)
      const sseUrl = `/api/angelone/live-stream-ws?symbol=${position.symbol}&symbolToken=${symbolToken}&exchange=${exchange}&tradingSymbol=${position.symbol}&interval=0`; // 0 = 700ms live tick data

      console.log(`📡 [PAPER-TRADING] Subscribing to ${position.symbol} live stream`);

      const eventSource = new EventSource(sseUrl);
      paperTradingEventSourcesRef.current.set(position.symbol, eventSource);

      eventSource.onopen = () => {
        console.log(`✅ [PAPER-TRADING] Connected: ${position.symbol}`);
        setPaperTradingWsStatus('connected');
      };

      eventSource.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          const ltp = data.ltp || data.close;

          if (ltp && ltp > 0) {
            paperTradingLastUpdateRef.current = Date.now();

            // Update live prices map
            setPaperTradingLivePrices(prev => {
              const newMap = new Map(prev);
              newMap.set(position.symbol, ltp);
              return newMap;
            });

            // Update position with new price and recalculate P&L
            // CRITICAL: Account for trade direction (BUY = long, SELL = short)
            setPaperPositions(prevPositions => {
              return prevPositions.map(p => {
                if (p.symbol === position.symbol && p.isOpen) {
                  // For BUY (long): P&L = (current - entry) * qty (profit when price rises)
                  // For SELL (short): P&L = (entry - current) * qty (profit when price falls)
                  const priceDiff = p.action === 'BUY' 
                    ? (ltp - p.entryPrice) 
                    : (p.entryPrice - ltp);
                  const pnl = priceDiff * p.quantity;
                  const pnlPercent = (priceDiff / p.entryPrice) * 100;
                  return {
                    ...p,
                    currentPri