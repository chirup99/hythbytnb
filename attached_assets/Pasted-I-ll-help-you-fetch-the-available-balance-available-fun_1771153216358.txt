I'll help you fetch the available balance (available funds) from the Delta Exchange API.## How to Fetch Available Balance (Available Funds) from Delta Exchange API

Here's a complete guide on fetching available balance from Delta Exchange.

Understanding Available Balance
Available Balance = Total Balance - Blocked Margin

The available_balance field shows the funds you can use for new trades. It's calculated by subtracting all blocked margins (positions, orders, commissions) from your total balance.

Endpoint: Get Wallet Balances
Endpoint: GET /v2/wallet/balances

Description: Returns wallet balances including available balance for all assets.

Authentication: Required

Parameters: None

Key Balance Fields
balance (string): Total wallet balance
available_balance (string): Balance available for trading (balance - blocked_margin)
available_balance_for_robo (string): Balance available for robo trading
blocked_margin (string): Total blocked margin (positions + orders + commissions)
Example Request

curl -X GET "https://api.india.delta.exchange/v2/wallet/balances" \
  -H "api-key: your_api_key" \
  -H "timestamp: 1542110948" \
  -H "signature: your_generated_signature" \
  -H "User-Agent: python-rest-client" \
  -H "Content-Type: application/json"

Sample Response

{
  "success": true,
  "result": [
    {
      "id": 1,
      "user_id": 98765432,
      "asset_id": 1,
      "asset_symbol": "BTC",
      "balance": "1.00000000",
      "available_balance": "0.85000000",
      "available_balance_for_robo": "0.85000000",
      "blocked_margin": "0.15000000",
      "order_margin": "0.05000000",
      "position_margin": "0.09000000",
      "commission": "0.01000000"
    },
    {
      "id": 2,
      "user_id": 98765432,
      "asset_id": 5,
      "asset_symbol": "USDT",
      "balance": "10000.00000000",
      "available_balance": "9200.00000000",
      "available_balance_for_robo": "9200.00000000",
      "blocked_margin": "800.00000000",
      "order_margin": "300.00000000",
      "position_margin": "450.00000000",
      "commission": "50.00000000"
    }
  ],
  "meta": {
    "net_equity": "11000.00",
    "robo_trading_equity": "10050.00"
  }
}

Python Implementation: Fetch Available Balance
Simple Version - Get Available Balance for All Assets

import hashlib
import hmac
import requests
import time

base_url = 'https://api.india.delta.exchange'
api_key = 'your_api_key'
api_secret = 'your_api_secret'

def generate_signature(secret, message):
    """Generate HMAC SHA256 signature"""
    message = bytes(message, 'utf-8')
    secret = bytes(secret, 'utf-8')
    hash = hmac.new(secret, message, hashlib.sha256)
    return hash.hexdigest()

def fetch_available_balances():
    """Fetch available balance for all assets"""
    
    # Prepare request
    method = 'GET'
    timestamp = str(int(time.time()))
    path = '/v2/wallet/balances'
    query_string = ''
    payload = ''
    
    # Generate signature
    signature_data = method + timestamp + path + query_string + payload
    signature = generate_signature(api_secret, signature_data)
    
    # Build headers
    headers = {
        'api-key': api_key,
        'timestamp': timestamp,
        'signature': signature,
        'User-Agent': 'python-rest-client',
        'Content-Type': 'application/json'
    }
    
    # Make request
    url = f'{base_url}{path}'
    
    try:
        response = requests.get(url, headers=headers, timeout=(3, 27))
        response.raise_for_status()
        data = response.json()
        
        if data.get('success'):
            wallets = data['result']
            
            print("=" * 70)
            print("AVAILABLE BALANCE FOR TRADING")
            print("=" * 70)
            print(f"\n{'Asset':<10} {'Total Balance':<20} {'Available':<20} {'Blocked':<15}")
            print("-" * 70)
            
            for wallet in wallets:
                balance = float(wallet['balance'])
                available = float(wallet['available_balance'])
                blocked = float(wallet['blocked_margin'])
                
                # Show all assets with balance or blocked margin
                if balance > 0 or blocked > 0:
                    print(f"{wallet['asset_symbol']:<10} "
                          f"{wallet['balance']:<20} "
                          f"{wallet['available_balance']:<20} "
                          f"{wallet['blocked_margin']:<15}")
            
            print("=" * 70)
            
            return wallets
        else:
            print(f"Failed to fetch balances: {data}")
            return None
            
    except requests.exceptions.RequestException as e:
        print(f"Error fetching balances: {e}")
        if hasattr(e, 'response') and e.response is not None:
            print(f"Response: {e.response.text}")
        return None

# Fetch and display available balances
wallets = fetch_available_balances()

Advanced Version - Get Available Balance for Specific Asset

import hashlib
    # Build headers
    headers = {
        'api-key': api_key,
        'timestamp': timestamp,
        'signature': signature,
        'User-Agent': 'python-rest-client',
        'Content-Type': 'application/json'
    }
    
    # Make request
    url = f'{base_url}{path}'
    
    try:
        response = requests.get(url, headers=headers, timeout=(3, 27))
        response.raise_for_status()
        data = response.json()
        
        if data.get('success'):
            wallets = data['result']
            
            # Find the specific asset
            for wallet in wallets:
                if wallet['asset_symbol'] == asset_symbol:
                    return {
                        'asset_symbol': wallet['asset_symbol'],
                        'asset_id': wallet['asset_id'],
                        'balance': wallet['balance'],
                        'available_balance': wallet['available_balance'],
                        'available_balance_for_robo': wallet['available_balance_for_robo'],
                        'blocked_margin': wallet['blocked_margin'],
                        'order_margin': wallet['order_margin'],
                        'position_margin': wallet['position_margin'],
                        'commission': wallet['commission']
                    }
            
            print(f"Asset {asset_symbol} not found in wallet")
            return None
        else:
            print(f"Failed to fetch balances: {data}")
            return None
            
    except requests.exceptions.RequestException as e:
        print(f"Error fetching balances: {e}")
        return None

# Example 1: Get USDT available balance
print("=" * 70)
print("USDT AVAILABLE BALANCE")
print("=" * 70)

usdt_balance = get_available_balance('USDT')
if usdt_balance:
    print(f"\nAsset:                {usdt_balance['asset_symbol']}")
    print(f"Total Balance:        {usdt_balance['balance']}")
    print(f"Available Balance:    {usdt_balance['available_balance']}")
    print(f"Blocked Margin:       {usdt_balance['blocked_margin']}")
    print(f"  - In Orders:        {usdt_balance['order_margin']}")
    print(f"  - In Positions:     {usdt_balance['position_margin']}")
    print(f"  - Commission:       {usdt_balance['commission']}")
    
    # Calculate percentage available
    total = float(usdt_balance['balance'])
    available = float(usdt_balance['available_balance'])
    if total > 0:
        percentage = (available / total) * 100
        print(f"\nPercentage Available: {percentage:.2f}%")

# Example 2: Get BTC available balance
print("\n" + "=" * 70)
print("BTC AVAILABLE BALANCE")
print("=" * 70)

btc_balance = get_available_balance('BTC')
if btc_balance:
    print(f"\nAsset:                {btc_balance['asset_symbol']}")
    print(f"Total Balance:        {btc_balance['balance']}")
    print(f"Available Balance:    {btc_balance['available_balance']}")
    print(f"Blocked Margin:       {btc_balance['blocked_margin']}")

print("=" * 70)

Complete Dashboard - All Assets with Available Balance

import hashlib
        print(f"Error: {e}")
        return None

# Fetch balances
balance_data = fetch_wallet_balances()

if balance_data and balance_data.get('success'):
    wallets = balance_data['result']
    meta = balance_data.get('meta', {})
    
    print("\n" + "=" * 90)
    print("AVAILABLE BALANCE DASHBOARD")
    print("=" * 90)
    
    # Account Summary
    if meta:
        print(f"\nAccount Summary:")
        print(f"  Net Equity:          {meta.get('net_equity', 'N/A')}")
        print(f"  Robo Trading Equity: {meta.get('robo_trading_equity', 'N/A')}")
    
    # Available Balance Table
    print(f"\n{'Asset':<10} {'Total':<18} {'Available':<18} {'Blocked':<18} {'% Available':<12}")
    print("-" * 90)
    
    for wallet in wallets:
        balance = float(wallet['balance'])
        available = float(wallet['available_balance'])
        blocked = float(wallet['blocked_margin'])
        
        if balance > 0 or blocked > 0:
            # Calculate percentage
            percentage = (available / balance * 100) if balance > 0 else 0
            
            print(f"{wallet['asset_symbol']:<10} "
                  f"{wallet['balance']:<18} "
                  f"{wallet['available_balance']:<18} "
                  f"{wallet['blocked_margin']:<18} "
                  f"{percentage:.2f}%")
    
    # Detailed Breakdown
    print("\n" + "=" * 90)
    print("DETAILED BREAKDOWN (Assets with Blocked Margin)")
    print("=" * 90)
    
    for wallet in wallets:
        blocked = float(wallet['blocked_margin'])
        
        if blocked > 0:
            print(f"\n{wallet['asset_symbol']} Details:")
            print(f"  Total Balance:           {wallet['balance']}")
            print(f"  Available for Trading:   {wallet['available_balance']}")
            print(f"  Available for Robo:      {wallet['available_balance_for_robo']}")
            print(f"  Blocked Margin:          {wallet['blocked_margin']}")
            print(f"    └─ Order Margin:       {wallet['order_margin']}")
            print(f"    └─ Position Margin:    {wallet['position_margin']}")
            print(f"    └─ Commission:         {wallet['commission']}")
            
            # Show cross margin details if applicable
            if float(wallet.get('cross_position_margin', 0)) > 0:
                print(f"  Cross Margin Details:")
                print(f"    └─ Position Margin:    {wallet['cross_position_margin']}")
                print(f"    └─ Order Margin:       {wallet['cross_order_margin']}")
                print(f"    └─ Commission:         {wallet['cross_commission']}")
            
            # Show portfolio margin if applicable
            if float(wallet.get('portfolio_margin', 0)) > 0:
                print(f"  Portfolio Margin:        {wallet['portfolio_margin']}")
    
    # Summary of available funds
    print("\n" + "=" * 90)
    print("QUICK SUMMARY")
    print("=" * 90)
    
    assets_with_funds = [w for w in wallets if float(w['available_balance']) > 0]
    
    if assets_with_funds:
        print("\nAssets with Available Balance:")
        for wallet in assets_with_funds:
            print(f"  {wallet['asset_symbol']}: {wallet['available_balance']} (available for trading)")
    else:
        print("\nNo available balance found in any asset.")
    
    print("=" * 90)

else:
    print("Failed to fetch wallet balances")

Real-Time Available Balance Updates via WebSocket
For real-time updates when your available balance changes:


import websocket
import json
import hashlib
import hmac
import time

api_key = 'your_api_key'
api_secret = 'your_api_secret'

def generate_signature(secret, message):
    message = bytes(message, 'utf-8')
    secret = bytes(secret, 'utf-8')
    hash = hmac.new(secret, message, hashlib.sha256)
    return hash.hexdigest()

def on_open(ws):
    print("WebSocket connected")
    
    # Authenticate
    method = 'GET'
    timestamp = str(int(time.time()))
    path = '/live'
    signature_data = method + timestamp + path
    signature = generate_signature(api_secret, signature_data)
    
    auth_message = {
        "type": "auth",
        "payload": {
            "api-key": api_key,
            "signature": signature,
            "timestamp": timestamp
        }
    }
    ws.send(json.dumps(auth_message))

def on_message(ws, message):
    data = json.loads(message)
    
    if data.get('type') == 'auth_result':
        if data.get('success'):
            print("Authenticated! Subscribing to margins channel...")
            
            # Subscribe to margins (balance updates)
            subscribe_message = {
                "type": "subscribe",
                "payload": {
                    "channels": [{"name": "margins"}]
                }
            }
            ws.send(json.dumps(subscribe_message))
    
    elif data.get('type') == 'margins':
        # Real-time balance update
        print(f"\n{'='*60}")
        print(f"BALANCE UPDATE - {data['asset_symbol']}")
        print(f"{'='*60}")
        print(f"Total Balance:        {data['balance']}")
        print(f"Available Balance:    {data['available_balance']}")
        print(f"Blocked Margin:       {data['blocked_margin']}")
        print(f"  - Order Margin:     {data['order_margin']}")
        print(f"  - Position Margin:  {data['position_margin']}")
        print(f"  - Commission:       {data['commission']}")
        
        # Calculate percentage
        balance = float(data['balance'])
        available = float(data['available_balance'])
        if balance > 0:
            percentage = (available / balance) * 100
            print(f"Percentage Available: {percentage:.2f}%")

def on_error(ws, error):
    print(f"Error: {error}")

def on_close(ws, close_status_code, close_msg):
    print("WebSocket closed")

# Connect to WebSocket
ws = websocket.WebSocketApp(
    'wss://socket.india.delta.exchange',
    on_open=on_open,
    on_message=on_message,
    on_error=on_error,
    on_close=on_close
)

print("Connecting to WebSocket for real-time balance updates...")
ws.run_forever()

Understanding the Balance Calculation

Total Balance = Deposits - Withdrawals + Realized PnL

Available Balance = Total Balance - Blocked Margin

Blocked Margin = Order Margin + Position Margin + Commission +
Cross Margin (if applicable) +
Portfolio Margin (if applicable)
Key Points:

Available Balance is what you can use for new trades
Blocked Margin includes funds locked in open orders and positions
Order Margin is blocked when you place orders
Position Margin is blocked when you have open positions
Commission is pre-blocked for potential trading fees
Quick Reference Functions

def get_total_available_balance():
    """Get total available balance across all assets"""
    balance_data = fetch_wallet_balances()
    if balance_data and balance_data.get('success'):
        return {
            wallet['asset_symbol']: wallet['available_balance']
            for wallet in balance_data['result']
            if float(wallet['available_balance']) > 0
        }
    return {}

def can_place_order(asset_symbol, required_margin):
    """Check if you have enough available balance to place an order"""
    balance = get_available_balance(asset_symbol)
    if balance:
        available = float(balance['available_balance'])
        return available >= float(required_margin)
    return False

# Usage
available_balances = get_total_available_balance()
print("Available Balances:", available_balances)

if can_place_order('USDT', 100):
    print("You can place the order")
else:
    print("Insufficient available balance")

Summary
To fetch available balance from Delta Exchange:

Use GET /v2/wallet/balances endpoint
Access the available_balance field for each asset
Formula: Available Balance = Total Balance - Blocked Margin
Real-time: Subscribe to margins WebSocket channel for live updates
The available_balance field is the most important value as it shows exactly how much you can use for new trades.

