                    const calculateTradingInsights = (data = tradingDataByDate) => {
                      const allData = Object.values(filteredHeatmapData).filter(
                        (data: any) =>
                          data &&
                          data.tradeHistory &&
                          Array.isArray(data.tradeHistory) &&
                          data.tradeHistory.length > 0,
                      );

                      if (allData.length === 0) {
                        return {
                          tagAnalysis: [],
                          overallStats: {
                            totalTrades: 0,
                            winRate: 0,
                            totalPnL: 0,
                          },
                          topPerformers: [],
                          worstPerformers: [],
                          tradingDayAnalysis: [],
                        };
                      }

                      // Tag-based performance analysis
                      const tagStats: any = {};
                      const dailyStats: any[] = [];

                      allData.forEach((dayData: any, index: number) => {
                        const trades = dayData.tradeHistory || [];
                        const tags = dayData.tradingTags || [];
                        const metrics = dayData.performanceMetrics;

                        // Calculate day statistics
                        if (metrics) {
                          dailyStats.push({
                            day: index + 1,
                            trades: metrics.totalTrades || trades.length,
                            winRate: parseFloat(metrics.winRate) || 0,
                            netPnL: metrics.netPnL || 0,
                            tags: tags,
                          });
                        }

                        // Analyze each tag's performance
                        tags.forEach((tag: string) => {
                          if (!tagStats[tag]) {
                            tagStats[tag] = {
                              tag,
                              tradingDays: 0,
                              totalTrades: 0,
                              wins: 0,
                              losses: 0,
                              totalPnL: 0,
                              winRate: 0,
                              avgPnL: 0,
                              bestDay: 0,
                              worstDay: 0,
                              totalDuration: 0,
                              durations: [],
                            };
                          }

                          const stats = tagStats[tag];
                          stats.tradingDays++;

                          if (metrics) {
                            stats.totalTrades += metrics.totalTrades || 0;
                            stats.wins += metrics.winningTrades || 0;
                            stats.losses += metrics.losingTrades || 0;
                            stats.totalPnL += metrics.netPnL || 0;
                            
                            // Track duration if available (assuming duration in minutes)
                            const duration = metrics.avgDuration || metrics.duration || 0;
                            if (duration > 0) {
                              stats.totalDuration += duration;
                              stats.durations.push(duration);
                            }
                            stats.bestDay = Math.max(
                              stats.bestDay,
                              metrics.netPnL || 0,
                            );
                            stats.worstDay = Math.min(
                              stats.worstDay,
                              metrics.netPnL || 0,
                            );
                          }
                        });
                      });

                      // Calculate final stats for each tag
                      Object.values(tagStats).forEach((stats: any) => {
                        stats.winRate =
                          stats.totalTrades > 0
                            ? (stats.wins / stats.totalTrades) * 100
                            : 0;
                        stats.avgPnL =
                          stats.tradingDays > 0
                            ? stats.totalPnL / stats.tradingDays
                            : 0;
                        
                        stats.avgDuration = stats.totalTrades > 0 ? (stats.totalDuration / stats.totalTrades) : 0;
                        
                        // Determine trading style
                        if (stats.avgDuration === 0) {
                          stats.tradingStyle = "Inconsistent";
                        } else if (stats.avgDuration < 15) {
                          stats.tradingStyle = "Scalper";
                        } else if (stats.avgDuration < 60) {
                          stats.tradingStyle = "Intraday";
                        } else if (stats.avgDuration < 1440) {
                          stats.tradingStyle = "Swing Trade";
                        } else {
                          stats.tradingStyle = "Holding";
                        }
                        
                        // Override for emotional exit if loss making with high duration
                        if (stats.totalPnL < 0 && stats.avgDuration > 30) {
                          stats.tradingStyle = "Emotional Panic Exit";
                        }
                        
                        // Check for inconsistency in durations
                        if (stats.durations.length > 2) {
                           const min = Math.min(...stats.durations);
                           const max = Math.max(...stats.durations);
                           if (max > min * 5) {
                             stats.tradingStyle = "Unconsistance Duration";
                           }
                        }
                      });

                      const tagAnalysis = Object.values(tagStats).sort(
                        (a: any, b: any) => b.totalPnL - a.totalPnL,
                      );

                      // Overall statistics
                      const totalTrades = tagAnalysis.reduce(
                        (sum: number, tag: any) => sum + tag.totalTrades,
                        0,
                      );
                      const totalPnL = tagAnalysis.reduce(
                        (sum: number, tag: any) => sum + tag.totalPnL,
                        0,
                      );
                      const totalWins = tagAnalysis.reduce(
                        (sum: number, tag: any) => sum + tag.wins,
                        0,
                      );
                      const overallWinRate =
                        totalTrades > 0 ? (totalWins / totalTrades) * 100 : 0;

                      const overallStats = {
                        totalTrades,
                        winRate: overallWinRate,
                        totalPnL,
                      };
                      const topPerformers = tagAnalysis.slice(0, 5);
                      const worstPerformers = tagAnalysis.slice(-3).reverse();

                      return {
                        tagAnalysis,
                        overallStats,
                        topPerformers,
                        worstPerformers,
                        tradingDayAnalysis: dailyStats,
                      };
                    };

                    // âœ… NEW: Use filtered heatmap data directly instead of complex insights
                    const filteredHeatmapData = getFilteredHeatmapData();
                    const insights = calculateTradingInsights(filteredHeatmapData);
                    const calculateHeatmapMetrics = () => {
                      const dates = Object.keys(filteredHeatmapData);
                      let totalPnL = 0;
                      let totalTrades = 0;
                      let winningTrades = 0;
                      let datesWithTrading = 0;
                      dates.forEach(dateKey => {
                        const dayData = filteredHeatmapData[dateKey];

                        // Handle both wrapped (AWS) and unwrapped formats
                        const metrics = dayData?.tradingData?.performanceMetrics || dayData?.performanceMetrics;

                        if (metrics) {
                          const netPnL = metrics.netPnL || 0;

                          // Only include dates with actual trading activity (non-zero P&L)
                          if (netPnL !== 0) {
                            totalPnL += netPnL;
