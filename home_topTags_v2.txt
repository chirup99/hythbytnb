                              const metrics = dayData?.tradingData?.performanceMetrics || dayData?.performanceMetrics;
                              const tags = dayData?.tradingData?.tradingTags || dayData?.tradingTags || [];

                              if (metrics) {
                                const netPnL = metrics.netPnL || 0;
                                totalPnL += netPnL;
                                totalTrades += metrics.totalTrades || 0;
                                winningTrades += metrics.winningTrades || 0;
                                trendData.push(netPnL);

                                // Track overtrading - check for tag or high trade count
                                if ((metrics.totalTrades || 0) > 10) {
                                  overTradingCount++;
                                  overTradingDates.push(dateKey);
                                }

                                // Also track if overtrading tag exists
                                if (Array.isArray(tags) && tags.length > 0) {
                                  const normalizedTags = tags.map((t: string) => t.trim().toLowerCase());
                                  if (normalizedTags.includes('overtrading')) {
                                    if (!overTradingDates.includes(dateKey)) {
                                      overTradingCount++;
                                      overTradingDates.push(dateKey);
                                    }
                                  }
                                }

                                if (Array.isArray(tags) && tags.length > 0) {
                                  const normalizedTags = tags.map((t: string) => t.trim().toLowerCase());
                                  if (normalizedTags.includes('fomo')) {
                                    fomoTrades++;
                                    fomoDates.push(dateKey);
}
                                  if (normalizedTags.includes('planned')) {
                                    plannedCount++;
                                    plannedDates.push(dateKey);
                                  }
                                  // Track all tags with their dates
                                  normalizedTags.forEach(tag => {
                                    tagStats[tag] = (tagStats[tag] || 0) + 1;
                                    if (!tagDates[tag]) tagDates[tag] = [];
                                    tagDates[tag].push(dateKey);
                                  });
                                }

                                if (netPnL > 0) {
                                  consecutiveWins++;
                                  maxWinStreak = Math.max(maxWinStreak, consecutiveWins);
                                } else if (netPnL < 0) {
                                  consecutiveWins = 0;
                                }
                              }
                            });

                            const winRate = totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0;
                            const isProfitable = totalPnL >= 0;
                            const topTags = Object.entries(tagStats)
                              .sort(([,a], [,b]) => b - a)
                              .slice(0, 3)
                              .map(([tag, count]) => ({ tag, count }));

                            const createSparkline = (data: number[]) => {
                              if (data.length === 0) return '';
                              const max = Math.max(...data);
                              const min = Math.min(...data);
                              const range = max - min || 1;
                              const width = 40;
                              const height = 16;
                              const points = data.map((val, i) => {
                                const x = (i / (data.length - 1 || 1)) * width;
                                const y = height - ((val - min) / range) * height;
